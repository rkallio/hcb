#+todo: TODO | DONE

* Table of contents                                                     :TOC:
- [[#the-assignment][The assignment]]
  - [[#the-exercise][The exercise]]
  - [[#stuff-to-do][Stuff to do]]
  - [[#functional-requirements][Functional requirements]]
    - [[#data-import][Data import]]
    - [[#journey-list-view][Journey list view]]
    - [[#station-list][Station list]]
    - [[#single-station-view][Single station view]]
    - [[#surprise-us-with][Surprise us with]]
- [[#requirements][Requirements]]
  - [[#must][Must]]
    - [[#implement-the-software-product-the-app-as-a-cloud-native-application][Implement the software product (“The app”) as a cloud native application]]
    - [[#software-delivered-as-cloud-run-containers][Software delivered as Cloud run containers]]
    - [[#build-and-deploy-the-app-using-cloud-build][Build and deploy the app using Cloud build]]
    - [[#store-and-deliver-static-assets-from-cloud-storage][Store and deliver static assets from Cloud Storage]]
    - [[#implement-end-to-end-tests][Implement end-to-end tests]]
    - [[#the-frontend-04][The frontend]]
  - [[#should][Should]]
    - [[#the-frontend-03][The frontend]]
  - [[#could][Could]]
  - [[#wish][Wish]]
    - [[#run-automated-tests-in-gcp][Run automated tests in GCP]]
    - [[#endpoints-to-store-new-journeys-data-or-new-bicycle-stations][Endpoints to store new journeys data or new bicycle stations]]
    - [[#the-frontend][The frontend]]
    - [[#create-ui-for-adding-journeys-or-bicycle-stationc][Create UI for adding journeys or bicycle stationc]]
- [[#resources][Resources]]
  - [[#assignment-requirements-specification][Assignment, requirements specification]]
  - [[#academy-homepage][Academy homepage]]
  - [[#tips][Tips]]
  - [[#datasets][Datasets]]
    - [[#journey-dataset][Journey dataset]]
    - [[#bicycle-station-dataset][Bicycle station dataset]]
  - [[#contacts][Contacts]]
    - [[#project-contact][Project contact]]
    - [[#dataset-contacts][Dataset contacts]]
- [[#minutes--journal][Minutes & Journal]]
  - [[#get-acquainted-with-the-project-assignment][Get acquainted with the project assignment]]
  - [[#collect-requirements][Collect requirements]]
  - [[#explore-the-dataset][Explore the dataset]]
    - [[#journeys-csvs][Journeys CSVs]]
    - [[#station-csv][Station CSV]]
  - [[#write-the-frontend][Write the frontend]]
  - [[#mock-up-journeys-list-view][Mock up journeys list view]]
  - [[#explore-hosting-options-on-google-cloud][Explore hosting options on google cloud]]
  - [[#set-up-cloud-sql][Set up cloud SQL]]
- [[#implementation][Implementation]]
  - [[#the-frontend-1][The frontend]]
    - [[#journey-list-view-1][Journey list view]]
  - [[#the-backend][The backend]]
  - [[#the-database][The database]]
  - [[#the-datapump][The datapump]]
  - [[#the-map-frontend][The map frontend]]

* The assignment

Text here lifted from the [[id:40872028-9B66-4C60-BCEA-0F8D427CBF74][repository]].

** The exercise

Create a *web application* that uses a *backend service* to fetch the data. *Backend* can be made with any technology. We at Solita use for example (not in preference order) Java/Kotlin/Clojure/C#/TypeScript/Go but you are free to choose any other technology as well.

Backend can use a database, or it can be memory-based. *Real database use is a preferable* choice because it allows you to show broader skills. Also, the datasets are quite big so in-memory operations may be quite slow.

You can also freely choose the frontend (and possibly mobile frontend) technologies to use. The important part is to give good instructions on how to build and run the project.

** Stuff to do

Important! Implementing all of the proposed features is not needed for a good exercise result. You may also concentrate on:

+ Good documentation (readme/other docs)
+ Proper git usage (small commits, informative commit messages)
+ Tests
+ Getting features complete
+ Writing good code
+ Which are all highly valued in a good repository.

** Functional requirements

Focus on the recommended features. For extra points, you might want to also complete some additional features. You can also come up with extra features, if you do, please document them in the readme!

*** Data import

**** Recommended

*****  Import data from the CSV files to a database or in-memory storage

***** Validate data before importing

***** Don't import journeys that lasted for less than ten seconds

***** Don't import journeys that covered distances shorter than 10 meters

*** Journey list view
:PROPERTIES:
:ID:       3021535E-D457-4E21-B296-4035BCE2E439
:END:

**** Recommended

***** List journeys
:PROPERTIES:
:ID:       B4893559-616F-40BF-921F-7D317A7A3233
:END:

If you don't implement pagination, use some hard-coded limit for the list length because showing several million rows would make any browser choke

***** For each journey show departure and return stations, covered distance in kilometers and duration in minutes
:PROPERTIES:
:ID:       9C02BABD-4912-400F-91BE-7ACE4403DE58
:END:

**** Additional
:PROPERTIES:
:ID:       7DC9F915-F042-4FD0-8B35-F1CB41822661
:END:

***** Pagination
:PROPERTIES:
:ID:       C3F75C9E-BF89-4BA2-8FF9-6A0834A5FD9C
:END:

***** Ordering per column
:PROPERTIES:
:ID:       E0C31B66-06FB-41CE-997D-B0C7263C453C
:END:

***** Searching
:PROPERTIES:
:ID:       46BC5278-F5AE-4111-81CE-FABBBBDF2CCC
:END:

***** Filtering
:PROPERTIES:
:ID:       E59913C7-F2CA-46EB-BDF2-F6DDC2DEFCDE
:END:

*** Station list
:PROPERTIES:
:ID:       89C5ADDA-6E9D-485B-877F-2A47D765789A
:END:

**** Recommended
:PROPERTIES:
:ID:       560F2659-2E0A-43CC-B784-071D774D9305
:END:

***** List all the stations
:PROPERTIES:
:ID:       2E7F4555-4A42-4A5F-96CD-B917DED9F27F
:END:

**** Additional
:PROPERTIES:
:ID:       501D1AFF-D0DE-4C8F-9557-CFF81447EA1C
:END:

***** Pagination
:PROPERTIES:
:ID:       57A6951C-D5B4-4ABE-90CC-9737DB955055
:END:

***** Searching
:PROPERTIES:
:ID:       1A851198-298A-417B-9E16-091C0F722A69
:header-args:sql: :engine postgres :database hcb :dbuser postgres :dbpassword postgres :dbhost localhost :dbport 5432
:END:

#+begin_src sql
\d+ station
#+end_src

#+RESULTS:
| Table "public.station"                  |                  |           |          |         |          |             |              |             |
|-----------------------------------------+------------------+-----------+----------+---------+----------+-------------+--------------+-------------|
| Column                                  | Type             | Collation | Nullable | Default | Storage  | Compression | Stats target | Description |
| fid                                     | integer          |           | not null |         | plain    |             |              |             |
| id                                      | text             |           |          |         | extended |             |              |             |
| finnish_name                            | text             |           |          |         | extended |             |              |             |
| swedish_name                            | text             |           |          |         | extended |             |              |             |
| english_name                            | text             |           |          |         | extended |             |              |             |
| finnish_address                         | text             |           |          |         | extended |             |              |             |
| swedish_address                         | text             |           |          |         | extended |             |              |             |
| finnish_city                            | text             |           |          |         | extended |             |              |             |
| swedish_city                            | text             |           |          |         | extended |             |              |             |
| operator                                | text             |           |          |         | extended |             |              |             |
| capacity                                | integer          |           |          |         | plain    |             |              |             |
| x                                       | double precision |           |          |         | plain    |             |              |             |
| y                                       | double precision |           |          |         | plain    |             |              |             |
| Indexes:                                |                  |           |          |         |          |             |              |             |
| "station_pkey" PRIMARY KEY, btree (fid) |                  |           |          |         |          |             |              |             |
| Access method: heap                     |                  |           |          |         |          |             |              |             |

#+begin_src sql
SELECT english_name, finnish_address
FROM station
WHERE    english_name    ILIKE '%kannel%'
      OR finnish_address ILIKE '%kannel%'
LIMIT 10;
#+end_src

#+RESULTS:
| english_name               | finnish_address |
|----------------------------+-----------------|
| Kannelmäen liikuntapuisto  | Kanneltie 12    |
| Kannelmäki railway station | Sitratori 2     |


*** Single station view
:PROPERTIES:
:ID:       8B7AC0C5-E098-401C-936F-9B8AA51B8AB4
:END:

**** Recommended
:PROPERTIES:
:ID:       3FE0134F-3D02-44E6-B340-28C7100F2AEA
:END:

***** Station name
:PROPERTIES:
:ID:       A85600E0-7208-4CA2-98A5-C7B4AB286607
:END:

***** Station address
:PROPERTIES:
:ID:       EDD7F112-7D78-4308-AEBB-EBB652CF1E19
:END:

***** Total number of journeys starting from the station
:PROPERTIES:
:ID:       8DC3256B-CE71-4C5D-98F8-620F56EA6A4D
:END:

***** Total number of journeys ending at the station
:PROPERTIES:
:ID:       BF6F35A7-ADFF-473D-9A84-03CA5A7EB6A3
:END:

**** Additional
:PROPERTIES:
:ID:       54FF5C21-84E5-452A-A254-1038B45C98B0
:END:

***** Station location on the map
:PROPERTIES:
:ID:       32E8AD8C-7075-41E2-857A-3028E260F2A0
:END:

***** The average distance of a journey starting from the station
:PROPERTIES:
:ID:       BE865AC1-498E-4211-B2E3-D0E6E5748D14
:END:

***** The average distance of a journey ending at the station
:PROPERTIES:
:ID:       9CE27BCA-212A-4652-926E-0A19EF9B41B4
:END:

***** Top 5 most popular return stations for journeys starting from the station
:PROPERTIES:
:ID:       D42F365F-AF8D-42DC-8BD9-569C7CE7A633
:END:

***** Top 5 most popular departure stations for journeys ending at the station
:PROPERTIES:
:ID:       3A44653C-D103-493F-B9BC-E5FD1114E582
:END:

***** Ability to filter all the calculations per month
:PROPERTIES:
:ID:       FC0D1A36-1AC4-4062-BE61-778E63EEAB71
:END:

*** Surprise us with

**** Endpoints to store new journeys data or new bicycle stations
:PROPERTIES:
:ID:       0E3E7F1C-06BC-4E1D-BD78-070E8C6318BC
:END:

**** Running backend in Docker

**** Running backend in Cloud

**** Implement E2E tests

**** Create UI for adding journeys or bicycle stations
:PROPERTIES:
:ID:       4105F08E-4AE4-4A2F-BB4F-EC9C9F9B275B
:END:

* Requirements

This section defines the requirements by importance as defined by me.  The requirements defined in the [[id:6893CF22-FA13-475C-89DE-36E7E2B33128][must]] section must be implemented for me to return the assignment.  I will be happy if everything in the [[id: 1DB8A845-6E20-4E41-86CF-12F6496ED110][should]] section is implemented.  Implementing any item in the [[id:7FDED9CD-5D9A-4F4E-8726-86548002F5E5][could]] section is very low priority, and will likely only be done if the effort to do so is very low.

** Must
:PROPERTIES:
:ID:       6893CF22-FA13-475C-89DE-36E7E2B33128
:END:

*** TODO Implement the software product (“The app”) as a cloud native application

All the pieces that make up “the app” must run on server’s provided by GCP.

*** TODO Software delivered as Cloud run containers

Any piece of custom software must be deployable as a containerized app using cloud run.

*** TODO Build and deploy the app using Cloud build

*** TODO Store and deliver static assets from Cloud Storage

*** TODO Implement end-to-end tests

*** TODO The frontend [0/4]
:PROPERTIES:
:ID:       1659CF90-34E8-4D6B-BBC8-B347089D2089
:END:

**** TODO List journeys

See [[id:B4893559-616F-40BF-921F-7D317A7A3233]].

**** TODO For each journey, show [0/3]

Details: [[id:9C02BABD-4912-400F-91BE-7ACE4403DE58]].

***** TODO Departure and return stations

***** TODO Covered distance in kilometers

***** TODO Duration in minutes

**** TODO Station list [0/1]

See [[id:560F2659-2E0A-43CC-B784-071D774D9305]].

***** TODO List all the stations

See [[id:2E7F4555-4A42-4A5F-96CD-B917DED9F27F]].

**** TODO Single station view [0/4]

See [[id:3FE0134F-3D02-44E6-B340-28C7100F2AEA]].

***** TODO Station name

See [[id:A85600E0-7208-4CA2-98A5-C7B4AB286607]].

***** TODO Station address

See [[id:EDD7F112-7D78-4308-AEBB-EBB652CF1E19]].

***** TODO Total number of journeys starting from the station

See [[id:8DC3256B-CE71-4C5D-98F8-620F56EA6A4D]].

***** TODO Total number of journeys ending at the station

See [[id:BF6F35A7-ADFF-473D-9A84-03CA5A7EB6A3]].

** Should
:PROPERTIES:
:ID:       1DB8A845-6E20-4E41-86CF-12F6496ED110
:END:

*** TODO The frontend [0/3]
:PROPERTIES:
:ID:       27D03FC8-96B7-4F0B-94C0-A1E027CBADB0
:END:

**** TODO List journeys [0/4]

See [[id:7DC9F915-F042-4FD0-8B35-F1CB41822661]].

***** TODO Implement paginatioin

See [[id:C3F75C9E-BF89-4BA2-8FF9-6A0834A5FD9C]].

***** TODO Implement ordering per column

See [[id:E0C31B66-06FB-41CE-997D-B0C7263C453C]].

***** TODO Searching

See [[id:46BC5278-F5AE-4111-81CE-FABBBBDF2CCC]].

***** TODO Filtering

See [[id:E59913C7-F2CA-46EB-BDF2-F6DDC2DEFCDE]].

**** TODO Station list [0/2]

See [[id:501D1AFF-D0DE-4C8F-9557-CFF81447EA1C]].

***** TODO Pagination

See [[id:57A6951C-D5B4-4ABE-90CC-9737DB955055]].

***** TODO Searching

See [[id:1A851198-298A-417B-9E16-091C0F722A69]].

**** TODO Single station view [0/6]

See [[id:54FF5C21-84E5-452A-A254-1038B45C98B0]].

***** TODO Station location on the map(!)

See [[id:32E8AD8C-7075-41E2-857A-3028E260F2A0]].

This seems like a very big task, as it is the only requirement in the assignment that references an actual map

***** TODO Average distance of a journey starting from the station

See [[id:BE865AC1-498E-4211-B2E3-D0E6E5748D14]].

***** TODO Average distance of a journey ending at the station

See [[id:9CE27BCA-212A-4652-926E-0A19EF9B41B4]].

***** TODO 5 most popular return stations jor journeys starting from the station

See [[id:D42F365F-AF8D-42DC-8BD9-569C7CE7A633]].

***** TODO 5 most popular departure stations jor journeys ending at the station

See [[id:3A44653C-D103-493F-B9BC-E5FD1114E582]].

***** TODO Ability fo filter all the calculations per month

See [[id:FC0D1A36-1AC4-4062-BE61-778E63EEAB71]].

** Could
:PROPERTIES:
:ID:       7FDED9CD-5D9A-4F4E-8726-86548002F5E5
:END:

** Wish

*** TODO Run automated tests in GCP

This is a nice to have feature, but not necessary, as breakage after deploys is not world ending.  It also is not a functional requirement.

*** TODO Endpoints to store new journeys data or new bicycle stations

See [[id:0E3E7F1C-06BC-4E1D-BD78-070E8C6318BC]].

*** The frontend
:PROPERTIES:
:ID:       B1773244-DBCA-4154-92DB-54D718912754
:END:

*** TODO Create UI for adding journeys or bicycle stationc

See [[id:4105F08E-4AE4-4A2F-BB4F-EC9C9F9B275B]].

* Resources

** Assignment, requirements specification
:PROPERTIES:
:ID:       40872028-9B66-4C60-BCEA-0F8D427CBF74
:END:

[[https://github.com/solita/dev-academy-2023-exercise]]

** Academy homepage

[[https://www.solita.fi/positions/dev-academy-to-boost-your-software-developer-career-5202331003/]]

** Tips

+ [[https://dev.solita.fi/2021/11/04/how-to-pre-assignments.html][Do’s and Dont’s of pre-assignments]]
+ [[https://dev.solita.fi/2023/03/24/how-to-pre-assignments-2.html][Do's and Don'ts of Dev Academy Pre-assignments – Revisited]]
+ [[https://dev.solita.fi/2022/11/01/testing-primer-dev-academy.html][Testing Primer]] – tips on how to test your application

** Datasets

*** Journey dataset

Contact information for the dataset: [[id:749A080A-801E-4BB1-A8B6-6F4FAC42BE4F]].

+ [[https://dev.hsl.fi/citybikes/od-trips-2021/2021-05.csv]]
+ [[https://dev.hsl.fi/citybikes/od-trips-2021/2021-06.csv]]
+ [[https://dev.hsl.fi/citybikes/od-trips-2021/2021-07.csv]]

*** Bicycle station dataset

+ Data: [[https://opendata.arcgis.com/datasets/726277c507ef4914b0aec3cbcfcbfafc_0.csv]]
+ License information: [[https://www.avoindata.fi/data/en/dataset/hsl-n-kaupunkipyoraasemat/resource/a23eef3a-cc40-4608-8aa2-c730d17e8902]]

** Contacts

*** Project contact

[[mailto:pauliinahovila@solita.fi]]

*** Dataset contacts
:PROPERTIES:
:ID:       749A080A-801E-4BB1-A8B6-6F4FAC42BE4F
:END:

+ [[mailto:heikki.hamalainen@solita.fi]]
+ [[mailto:meri.merkkiniemi@solita.fi]]

* Minutes & Journal

** Get acquainted with the project assignment
:LOGBOOK:
CLOCK: [2023-04-01 Sat 20:10]--[2023-04-01 Sat 20:40] =>  0:30
:END:

** Collect requirements
:LOGBOOK:
CLOCK: [2023-04-02 Sun 09:04]--[2023-04-02 Sun 09:37] =>  0:33
CLOCK: [2023-04-01 Sat 20:41]--[2023-04-01 Sat 21:14] =>  0:33
:END:

** Explore the dataset
:PROPERTIES:
:header-args: :noweb yes
:ID:       8FAC00D2-5DBC-4127-B7F6-EE8244DEAF7A
:END:
:LOGBOOK:
CLOCK: [2023-04-07 Fri 20:40]--[2023-04-07 Fri 21:00] =>  0:20
CLOCK: [2023-04-07 Fri 19:44]--[2023-04-07 Fri 19:46] =>  0:02
CLOCK: [2023-04-07 Fri 15:58]--[2023-04-07 Fri 18:51] =>  1:38
CLOCK: [2023-04-02 Sun 09:38]--[2023-04-02 Sun 10:05] =>  0:27
CLOCK: [2023-04-01 Sat 22:51]--[2023-04-01 Sat 23:46] =>  0:55
CLOCK: [2023-04-01 Sat 22:29]--[2023-04-01 Sat 22:38] =>  0:09
CLOCK: [2023-04-01 Sat 21:15]--[2023-04-01 Sat 22:17] =>  1:02
:END:

*** Journeys CSVs
:LOGBOOK:
CLOCK: [2023-04-08 Sat 21:39]--[2023-04-08 Sat 22:36] =>  0:57
CLOCK: [2023-04-08 Sat 00:58]--[2023-04-08 Sat 01:05] =>  0:07
:END:
The journey dataset consists of three files, one file for the data of one month.

CSV header defines the following fields:
+ Departure
+ Return
+ Departure station id
+ Departure station name
+ Return station id
+ Return station name
+ Covered distance (m)
+ Duration (sec)

AKA this thing:

#+name: JourneyRecordTuple
#+begin_src python
from collections import namedtuple

JourneyRecord = namedtuple(
    'JourneyRecord',
    'departure_time,return_time,departure_id,departure_name,return_id,return_name,distance,duration'
)
#+end_src

#+header: :cache yes
#+header: :dir ../dataset/
#+begin_src python
import csv

f = '2021-05.csv'

<<JourneyRecordTuple>>

reader = csv.reader(open(f, 'r'))
# skip the header
next(reader)
print(list(map(JourneyRecord._make, reader))[1:2])
#+end_src

#+RESULTS[2684a09d41a676953da92f9c5450e4deecae00a0]:
: [JourneyRecord(departure_time='2021-05-31T23:56:59', return_time='2021-06-01T00:07:14', departure_id='082', departure_name='Töölöntulli', return_id='113', return_name='Pasilan asema', distance='1870', duration='611')]

Departure seems to be a timestamp without a timezone, same for Return.  I'll just assume this is in UTC and move on.

Departure station id and return station id seem to strings, because they may start with a 0.  +Distance and duration are ints+.  Only duration is always an int, distance may be the empty string, or a float.  Let's set the distance to 0 if it is represented as an empty string.  Departure and return stations names seem to be simple strings.

Here's a parser to check if I'm right.

#+name: JourneyParser
#+begin_src python
<<JourneyRecordTuple>>

from datetime import datetime


class Journey:
    def __init__(
            self,
            departure_time,
            return_time,
            departure_station_id,
            departure_station_name,
            return_station_id,
            return_station_name,
            distance,
            duration
    ):
        self.departure_time = departure_time
        self.return_time = return_time
        self.departure_station_id = departure_station_id
        self.departure_station_name = departure_station_name
        self.return_station_id = return_station_id
        self.return_station_name = return_station_name
        self.distance = distance
        self.duration = duration


    def from_journey_record(record):
        return Journey(
            record.departure_time,
            record.return_time,
            record.departure_id,
            record.departure_name,
            record.return_id,
            record.return_name,
            record.distance,
            record.duration
        )

    @property
    def duration(self):
        return self._duration

    @duration.setter
    def duration(self, duration):
        if isinstance(duration, str):
            duration = int(duration)
        if not isinstance(duration, int):
            raise ValueError('???')
        self._duration = duration

    @property
    def distance(self):
        return self._distance

    @distance.setter
    def distance(self, distance):
        if isinstance(distance, str):
            if distance == '':
                distance = 0.0
            else:
                distance = float(distance)
        if not isinstance(distance, float):
            raise ValueError('???')
        self._distance = distance

    @property
    def return_station_name(self):
        return self._return_station_name

    @return_station_name.setter
    def return_station_name(self, return_station_name):
        if not isinstance(return_station_name, str):
            raise ValueError('???')
        self._return_station_name = return_station_name

    @property
    def return_station_id(self):
        return self._return_station_id

    @return_station_id.setter
    def return_station_id(self, return_station_id):
        if not isinstance(return_station_id, str):
            raise ValueError('???')
        self._return_station_id = return_station_id

    @property
    def departure_station_name(self):
        return self._departure_station_name

    @departure_station_name.setter
    def departure_station_name(self, departure_station_name):
        if not isinstance(departure_station_name, str):
            raise ValueError('???')
        self._departure_station_name = departure_station_name

    @property
    def departure_station_id(self):
        return self._departure_station_id

    @departure_station_id.setter
    def departure_station_id(self, departure_station_id):
        if not isinstance(departure_station_id, str):
            raise ValueError('???')
        self._departure_station_id = departure_station_id

    @property
    def return_time(self):
        return self._return_time

    @return_time.setter
    def return_time(self, return_time):
        if isinstance(return_time, str):
            return_time = datetime.fromisoformat(return_time)
        if not isinstance(return_time, datetime):
            raise ValueError('???')
        self._return_time = return_time

    @property
    def departure_time(self):
        return self._departure_time

    @departure_time.setter
    def departure_time(self, departure_time):
        if isinstance(departure_time, str):
            departure_time = datetime.fromisoformat(departure_time)
        if not isinstance(departure_time, datetime):
            raise ValueError('???')
        self._departure_time = departure_time

    def __repr__(self):
        return (
            'Journey('
            f'{str(self.departure_time)!r}, '
            f'{str(self.return_time)!r}, '
            f'{self.departure_station_id!r}, '
            f'{self.departure_station_name!r}, '
            f'{self.return_station_id!r}, '
            f'{self.return_station_name!r}, '
            f'{self.distance!r}, '
            f'{self.duration!r}'
            ')'
        )
#+end_src

We can check with the parser if all the data is now parseable.

#+header: :cache yes
#+header: :dir ../dataset/
#+begin_src python
import csv
import traceback

files = ['2021-05.csv', '2021-06.csv', '2021-07.csv']

<<JourneyParser>>

def try_parse(journey_record):
    try:
        return Journey.from_journey_record(journey_record)
    except Exception as e:
        print(traceback.format_exc(), end='')
        raise e

for f in files:
    reader = csv.reader(open(f, 'r', newline=''))
    # skip the header
    next(reader)
    list(map(try_parse, map(JourneyRecord._make, reader)))
#+end_src

#+RESULTS[6b314abaa957fbe31922465789c4ad91639619ee]:

Since this results in no output, we have a good enough parser for the data.

We can dump the data into an sqlite3 database.

#+header: :cache yes
#+header: :dir ../dataset/
#+begin_src python
import sqlite3

con = sqlite3.connect("journey.db")
cur = con.cursor()
query = """
CREATE TABLE IF NOT EXISTS journey(
  departure_time,
  return_time,
  departure_station_id,
  departure_station_name,
  return_station_id,
  return_station_name,
  distance,
  duration
)
"""
cur.execute(query)
tables = cur.execute("SELECT name from sqlite_master")

<<JourneyParser>>

import csv

files = ['2021-05.csv', '2021-06.csv', '2021-07.csv']
for f in files:
    reader = csv.reader(open(f, 'r', newline=''))
    # skip the header
    next(reader)
    for journey in map(
            Journey.from_journey_record,
            (map(JourneyRecord._make, reader))):
        cur.execute(
            "INSERT INTO journey VALUES(?, ?, ?, ?, ?, ?, ? ,?)",
            (journey.departure_time,
             journey.return_time,
             journey.departure_station_id,
             journey.departure_station_name,
             journey.return_station_id,
             journey.return_station_name,
             journey.distance,
             journey.duration)
        )
con.commit()
con.close()
#+end_src

#+RESULTS[a754e722ce2e73a672bfd92b059904ac186de661]:

And then look up stuff I guess.

#+header: :dir ../dataset
#+begin_src python
import sqlite3

con = sqlite3.connect("journey.db")
query = "SELECT * FROM journey LIMIT 1"
res=con.execute(query)
print(res.fetchone())
con.close()
#+end_src

#+RESULTS:
: ('2021-05-31 23:57:25', '2021-06-01 00:05:46', '094', 'Laajalahden aukio', '100', 'Teljäntie', 2043.0, 500)

And then push to a psql server

#+begin_src sh
podman network create postgres
podman run --rm -d \
       --name postgres-server \
       --network=postgres \
       -p5432:5432 \
       -e POSTGRES_PASSWORD=postgres \
       postgres
#+end_src

#+header: :tangle ../dataset/export-to-psql-requirements.txt
#+begin_src text
psycopg2-binary
#+end_src

#+header: :tangle ../dataset/export-to-psql.py
#+begin_src python
import psycopg2
import os


conn = psycopg2.connect(
    database=os.environ['PSQL_POSTGRES_DB'],
    user=os.environ['PSQL_USER'],
    password=os.environ['PSQL_PASS'],
    host=os.environ['PSQL_HOST'],
    port=os.environ['PSQL_PORT']
)

conn.autocommit = True

from psycopg2.errors import DuplicateDatabase

try:
    with conn.cursor() as cur:
        cur.execute("CREATE DATABASE hcb")
except DuplicateDatabase:
    pass
finally:
    conn.close()

conn = psycopg2.connect(
    database='hcb',
    user=os.environ['PSQL_USER'],
    password=os.environ['PSQL_PASS'],
    host=os.environ['PSQL_HOST'],
    port=os.environ['PSQL_PORT']
)
conn.autocommit = False

SQL = """
CREATE TABLE IF NOT EXISTS journey (
departure_time TIMESTAMP,
return_time TIMESTAMP,
departure_station_id TEXT,
departure_station_name TEXT,
return_station_id TEXT,
return_station_name TEXT,
distance FLOAT,
duration INTEGER
)
"""

cur = conn.cursor()
cur.execute(SQL)
SQL = "INSERT INTO journey VALUES(%s, %s, %s, %s, %s, %s, %s, %s)"

import sqlite3

scon = sqlite3.connect("journey.db")
query = "SELECT * FROM journey"
res=scon.execute(query)

<<JourneyParser>>

for i, journey in enumerate(map(Journey.from_journey_record, map(JourneyRecord._make, res.fetchall()))):
    cur.execute(
        SQL,
        (
            journey.departure_time,
            journey.return_time,
            journey.departure_station_id,
            journey.departure_station_name,
            journey.return_station_id,
            journey.return_station_name,
            journey.distance,
            journey.duration
        )
    )
    if i % 1000 == 0:
        print(i)

conn.commit()
scon.close()
conn.close()
#+end_src

Need an index if I want to implement stable sorting.

#+begin_src sql
ALTER TABLE journey
ADD COLUMN id SERIAL PRIMARY KEY;
#+end_src

How do I get this bad boy to Google SQL cheaply?

Almost all lines in the original csv's contain dups.

Here's a script that merges the files into one and deletes all dups.

#+header: :dir ../dataset
#+begin_src bash
cat <(tail +2 2021-05.csv) \
    <(tail +2 2021-06.csv) \
    <(tail +2 2021-07.csv) \
    | sort | uniq > journeys.csv
#+end_src

#+header: :dir ../dataset
#+begin_src sh
wc -l 2021-0?.csv journeys.csv
#+end_src

#+RESULTS:
|  814677 | 2021-05.csv  |
| 1223483 | 2021-06.csv  |
| 1208845 | 2021-07.csv  |
| 1623501 | journeys.csv |
| 4870506 | total        |

*** We want statistics
:PROPERTIES:
:header-args:sql: :engine postgres :database hcb :dbuser postgres :dbpassword postgres :dbhost localhost :dbport 5432
:END:

#+begin_src sql
WITH our_station AS (
     SELECT id
     FROM station
     WHERE fid = 1
)
SELECT COUNT(*) AS departures
FROM journey
JOIN our_station
ON journey.departure_station_id = our_station.id;
#+end_src

#+RESULTS:
| departures |
|------------|
|       4930 |

#+begin_src sql
SELECT COUNT(*) from journey
WHERE EXTRACT(MONTH FROM departure_time) IN (5, 6, 7);
#+end_src

#+RESULTS:
|   count |
|---------|
| 3247002 |

#+begin_src sql
WITH our_station AS (
     SELECT id
     FROM station
     WHERE fid = 1
)
SELECT COUNT(*) AS returns
FROM journey
JOIN our_station
ON journey.return_station_id = our_station.id;
#+end_src

#+RESULTS:
| returns |
|---------|
|    5072 |

#+begin_src sql
WITH our_station AS (
     SELECT id
     FROM station
     WHERE fid = 1
)
SELECT AVG(distance) as average_journey
FROM journey
JOIN our_station
ON journey.departure_station_id = our_station.id;
#+end_src

#+RESULTS:
|   average_journey |
|-------------------|
| 3655.007302231237 |

#+begin_src sql
WITH our_station AS (
     SELECT id
     FROM station
     WHERE fid = 1
)
SELECT AVG(distance) as average_journey
FROM journey
JOIN our_station
ON journey.return_station_id = our_station.id;
#+end_src

#+RESULTS:
|    average_journey |
|--------------------|
| 3773.3036277602523 |

#+begin_src sql
WITH station AS (
    SELECT *
    FROM station
    WHERE fid = 1
),
statistics AS (
    SELECT (
        SELECT id FROM station
    ), (
        SELECT AVG(distance) as average_departure_distance
        FROM journey
        JOIN station
        ON station.id = departure_station_id
        WHERE EXTRACT(MONTH FROM departure_time) IN (5, 6, 7)
    ) as avg_departure_distance,
    (
        SELECT AVG(distance) as average_return_distance
        FROM journey
        JOIN station
        ON station.id = return_station_id
        WHERE EXTRACT(MONTH FROM departure_time) IN (5, 6, 7)
    ) as avg_return_distance
)
SELECT avg_return_distance, avg_departure_distance
FROM station
JOIN statistics
ON station.id = statistics.id;
#+end_src

#+RESULTS:
| avg_return_distance | avg_departure_distance |
|---------------------+------------------------|
|  3773.3036277602523 |      3655.007302231237 |

#+begin_src sql
WITH our_station AS (
     SELECT id
     FROM station
     WHERE fid = 1
)
SELECT return_station_id, return_station_name, COUNT(return_station_id)
FROM journey
JOIN our_station
ON journey.departure_station_id = our_station.id
WHERE EXTRACT(MONTH FROM departure_time) IN (5, 6, 7)
GROUP BY return_station_name, journey.return_station_id
ORDER BY count DESC
LIMIT 5;
#+end_src

#+RESULTS:
| return_station_id | return_station_name      | count |
|-------------------+--------------------------+-------|
|               401 | Koivusaari (M)           |   376 |
|               501 | Hanasaari                |   292 |
|               057 | Lauttasaaren ostoskeskus |   246 |
|               055 | Puistokaari              |   224 |
|               505 | Westendinasema           |   222 |

#+begin_src sql
WITH our_station AS (
     SELECT id
     FROM station
     WHERE fid = 1
)
SELECT departure_station_id, departure_station_name, COUNT(return_station_id)
FROM journey
JOIN our_station
ON return_station_id = our_station.id
WHERE EXTRACT(MONTH FROM departure_time) IN (5, 6, 7)
GROUP BY departure_station_name, departure_station_id
ORDER BY count DESC
LIMIT 5;
#+end_src

#+RESULTS:
| departure_station_id | departure_station_name | count |
|----------------------+------------------------+-------|
|                  401 | Koivusaari (M)         |   406 |
|                  501 | Hanasaari              |   292 |
|                  055 | Puistokaari            |   244 |
|                  595 | Westendintie           |   214 |
|                  030 | Itämerentori           |   192 |

#+begin_src sql
WITH station AS (
    SELECT *
    FROM station
    WHERE fid = 1
),
statistics AS (
    SELECT (
        SELECT id FROM station
    ), (
        SELECT COUNT(*)
        FROM journey
        JOIN station
        ON station.id = departure_station_id
        WHERE EXTRACT(MONTH FROM departure_time) IN (5, 6, 7)
    ) as departures,
    ( SELECT COUNT(*)
        FROM journey
        JOIN station
        ON station.id = return_station_id
        WHERE EXTRACT(MONTH FROM departure_time) IN (5, 6, 7)
    ) as returns
)
SELECT returns, departures
FROM station
JOIN statistics
ON station.id = statistics.id;
#+end_src

#+RESULTS:
| returns | departures |
|---------+------------|
|    1410 |       4930 |

*** A random station
:PROPERTIES:
:header-args:sql: :engine postgres :database hcb :dbuser postgres :dbpassword postgres :dbhost localhost :dbport 5432
:END:

#+begin_src sql
SELECT fid from station
ORDER BY RANDOM()
LIMIT 1;
#+end_src

#+RESULTS:
| fid |
|-----|
| 344 |

*** Station CSV
:LOGBOOK:
CLOCK: [2023-04-08 Sat 00:15]--[2023-04-08 Sat 00:58] =>  0:43
:END:

Here's a parser for the station CSV.

#+name: StationTypes
#+begin_src python
from collections import namedtuple

StationRecord = namedtuple(
    'StationRecord',
    'fid,id,finnish_name,swedish_name,english_name,finnish_address,swedish_address,finnish_city,swedish_city,operator,capacity,x,y')

class Station:
    def __init__(
            self,
            fid,
            id,
            finnish_name,
            swedish_name,
            english_name,
            finnish_address,
            swedish_address,
            finnish_city,
            swedish_city,
            operator,
            capacity,
            x,
            y
    ):
        self.fid = fid
        self.id = id
        self.finnish_name = finnish_name
        self.swedish_name = swedish_name
        self.english_name = english_name
        self.finnish_address = finnish_address
        self.swedish_address = swedish_address
        self.finnish_city = finnish_city
        self.swedish_city = swedish_city
        self.operator = operator
        self.capacity = capacity
        self.x = x
        self.y = y

    @staticmethod
    def from_station_record(record):
        return Station(
            record.fid,
            record.id,
            record.finnish_name,
            record.swedish_name,
            record.english_name,
            record.finnish_address,
            record.swedish_address,
            record.finnish_city,
            record.swedish_city,
            record.operator,
            record.capacity,
            record.x,
            record.y
        )

    def __repr__(self):
        return (
            'Station('
            f'{str(self.fid)!r}, '
            f'{self.id!r}, '
            f'{self.finnish_name!r}, '
            f'{self.swedish_name!r}, '
            f'{self.english_name!r}, '
            f'{self.finnish_address!r}, '
            f'{self.swedish_address!r}, '
            f'{self.finnish_city!r},'
            f'{self.swedish_city!r},'
            f'{self.operator!r},'
            f'{str(self.capacity)!r},'
            f'{str(self.x)!r},'
            f'{str(self.y)!r}'
            ')'
        )

    @property
    def y(self):
        return self._y

    @y.setter
    def y(self, y):
        if isinstance(y, str):
            y = float(y)

        if not isinstance(y, float):
            raise ValueError()
        self._y = y

    @property
    def x(self):
        return self._x

    @x.setter
    def x(self, x):
        if isinstance(x, str):
            x = float(x)

        if not isinstance(x, float):
            raise ValueError()
        self._x = x

    @property
    def capacity(self):
        return self._capacity

    @capacity.setter
    def capacity(self, capacity):
        if isinstance(capacity, str):
            capacity = int(capacity)

        if not isinstance(capacity, int):
            raise ValueError()
        self._capacity = capacity

    @property
    def operator(self):
        return self._operator

    @operator.setter
    def operator(self, operator):
        if not isinstance(operator, str):
            raise ValueError()
        self._operator = operator

    @property
    def swedish_address(self):
        return self._swedish_address

    @swedish_address.setter
    def swedish_address(self, swedish_address):
        if not isinstance(swedish_address, str):
            raise ValueError()
        self._swedish_address = swedish_address

    @property
    def finnish_address(self):
        return self._finnish_address

    @finnish_address.setter
    def finnish_address(self, finnish_address):
        if not isinstance(finnish_address, str):
            raise ValueError()
        self._finnish_address = finnish_address

    @property
    def english_name(self):
        return self._english_name

    @english_name.setter
    def english_name(self, english_name):
        if not isinstance(english_name, str):
            raise ValueError()
        self._english_name = english_name

    @property
    def swedish_name(self):
        return self._swedish_name

    @swedish_name.setter
    def swedish_name(self, swedish_name):
        if not isinstance(swedish_name, str):
            raise ValueError()
        self._swedish_name = swedish_name

    @property
    def finnish_name(self):
        return self._finnish_name

    @finnish_name.setter
    def finnish_name(self, finnish_name):
        if not isinstance(finnish_name, str):
            raise ValueError()
        self._finnish_name = finnish_name

    @property
    def id(self):
        return self._id

    @id.setter
    def id(self, id):
        if not isinstance(id, str):
            raise ValueError()
        self._id = id

    @property
    def fid(self):
        return self._fid

    @fid.setter
    def fid(self, fid):
        if isinstance(fid, str):
            fid = int(fid)
        if not isinstance(fid, int):
            raise ValueError()
        self._fid = fid
#+end_src

#+RESULTS: StationTypes


Here's how I pushed the stuff into psql.

#+header: :tangle ../dataset/station-to-sql-requirements.txt
#+begin_src text
psycopg2-binary
#+end_src

#+header: :tangle ../dataset/station-to-sql.py
#+header: :dir ../dataset/
#+begin_src python
import csv
import pprint
import traceback
import psycopg2
import os
<<StationTypes>>

file = 'asemat.csv'

reader = csv.reader(open(file, 'r', newline=''))
# skip header
next(reader)
stations = map(Station.from_station_record, map(StationRecord._make, reader))


conn = psycopg2.connect(
    database='hcb',
    user=os.environ['PSQL_USER'],
    password=os.environ['PSQL_PASS'],
    host=os.environ['PSQL_HOST'],
    port=os.environ['PSQL_PORT']
)

SQL = """
CREATE TABLE IF NOT EXISTS station (
  fid INTEGER PRIMARY KEY,
  id TEXT,
  finnish_name TEXT,
  swedish_name TEXT,
  english_name TEXT,
  finnish_address TEXT,
  swedish_address TEXT,
  finnish_city TEXT,
  swedish_city TEXT,
  operator TEXT,
  capacity INTEGER,
  x FLOAT,
  y FLOAT
)
"""

cur = conn.cursor()
cur.execute(SQL)

SQL = "INSERT INTO station VALUES(%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)"

for station in stations:
    cur.execute(SQL, (
        station.fid,
        station.id,
        station.finnish_name,
        station.swedish_name,
        station.english_name,
        station.finnish_address,
        station.swedish_address,
        station.finnish_city,
        station.swedish_city,
        station.operator,
        station.capacity,
        station.x,
        station.y
    ))

conn.commit()
conn.close()
#+end_src

#+RESULTS:

** Write the frontend
:LOGBOOK:
CLOCK: [2023-04-09 Sun 14:49]--[2023-04-09 Sun 18:36] =>  3:47
CLOCK: [2023-04-08 Sat 23:02]--[2023-04-09 Sun 00:44] =>  1:42
CLOCK: [2023-04-08 Sat 22:36]--[2023-04-08 Sat 23:02] =>  0:26
CLOCK: [2023-04-08 Sat 21:28]--[2023-04-08 Sat 21:39] =>  0:11
CLOCK: [2023-04-08 Sat 11:29]--[2023-04-08 Sat 15:59] =>  4:30
CLOCK: [2023-04-08 Sat 01:06]--[2023-04-08 Sat 01:30] =>  0:24
CLOCK: [2023-04-07 Fri 20:04]--[2023-04-07 Fri 20:29] =>  0:25
CLOCK: [2023-04-07 Fri 15:29]--[2023-04-07 Fri 15:40] =>  0:11
CLOCK: [2023-04-07 Fri 14:29]--[2023-04-07 Fri 15:15] =>  0:46
CLOCK: [2023-04-06 Thu 12:20]--[2023-04-06 Thu 13:18] =>  0:58
CLOCK: [2023-04-06 Thu 10:56]--[2023-04-06 Thu 11:23] =>  0:27
CLOCK: [2023-04-02 Sun 10:22]--[2023-04-02 Sun 12:10] =>  1:48
:END:

Now that we have an sqlite database of the journey data, we can start implementing its view.  The “backend” used is going to be the sqlite database.

Spent the first 45 minutes fighting with setuptools because the directory I had the package in contained a space, great success.

Created project starter with command [[shell:cookiecutter gh:Pylons/pyramid-cookiecutter-starter]].  Project is in directory [[file:hcbf/]].

Journeys list view now exists, it fetches data straight from an sqlite database.  Implements pagination and the recommended fields.

Converted the frontend from pyramid to flask.

Added support for pgsql data source.

Implemented the stations view.

Added pagination to stations view.

Implemented filtering by month in single station view.

** Mock up journeys list view
:LOGBOOK:
CLOCK: [2023-04-06 Thu 12:09]--[2023-04-06 Thu 12:19] =>  0:10
CLOCK: [2023-04-06 Thu 10:45]--[2023-04-06 Thu 10:54] =>  0:09
:END:

** Explore hosting options on google cloud
:LOGBOOK:
CLOCK: [2023-04-06 Thu 21:39]--[2023-04-06 Thu 22:23] =>  0:44
CLOCK: [2023-04-06 Thu 16:40]--[2023-04-06 Thu 17:46] =>  1:06
CLOCK: [2023-04-06 Thu 14:59]--[2023-04-06 Thu 15:45] =>  0:46
CLOCK: [2023-04-06 Thu 13:21]--[2023-04-06 Thu 13:41] =>  0:20
:END:

I was intending to host using cloud run, but seems app engine would be a nice option as well.  Example pulled from here [[https://cloud.google.com/appengine/docs/standard/python3/building-app/writing-web-service]].

#+header: :mkdirp yes :tangle app-engine/templates/index.html
#+begin_src jinja2
<!doctype html>
<html>
  <head>
    <title>Datastore and Firebase Auth Example</title>
    <script src="{{ url_for('static', filename='script.js') }}"></script>
    <link type="text/css" rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  </head>
  <body>
    <h1>Datastore and Firebase Auth Example</h1>
    <h2>Last 10 visits</h2>
    {% for time in times %}
      <p>{{ time }}</p>
    {% endfor %}
  </body>
</html>
#+end_src

#+header: :mkdirp yes :tangle app-engine/static/script.js
#+begin_src js
'use strict';

window.addEventListener('load', function () {

  console.log("Hello World!");

});
#+end_src

#+header: :mkdirp yes :tangle app-engine/static/style.css
#+begin_src css
body {
  font-family: "helvetica", sans-serif;
  text-align: center;
}
#+end_src

#+header: :mkdirp yes :tangle app-engine/main.py
#+begin_src python
import datetime

from flask import Flask, render_template

app = Flask(__name__)


@app.route('/')
def root():
    # For the sake of example, use static information to inflate the
    # template.  This will be replaced with real information in later
    # steps.
    dummy_times = [
        datetime.datetime(2018, 1, 1, 10, 0, 0),
        datetime.datetime(2018, 1, 2, 10, 30, 0),
        datetime.datetime(2018, 1, 3, 11, 0, 0),
    ]

    return render_template('index.html', times=dummy_times)


if __name__ == '__main__':
    # This is used when running locally only. When deploying to Google
    # App Engine, a webserver process such as Gunicorn will serve the
    # app. This can be configured by adding an `entrypoint` to
    # app.yaml.  Flask's development server will automatically serve
    # static files in the "static" directory. See:
    # http://flask.pocoo.org/docs/1.0/quickstart/#static-files. Once
    # deployed, App Engine itself will serve those files as configured
    # in app.yaml.
    app.run(host='127.0.0.1', port=8080, debug=True)
#+end_src

#+header: :tangle app-engine/requirements.txt
#+begin_src text
Flask==2.1.0
#+end_src

#+header: :tangle app-engine/.gcloudignore
#+begin_src text
# This file specifies files that are *not* uploaded to Google Cloud
# using gcloud. It follows the same syntax as .gitignore, with the
# addition of "#!include" directives (which insert the entries of the
# given .gitignore-style file at that point).
#
# For more information, run:
#   $ gcloud topic gcloudignore
#
.gcloudignore
# If you would like to upload your .git directory, .gitignore file or files
# from your .gitignore file, remove the corresponding line
# below:
.git
.gitignore

# Python pycache:
__pycache__/
# Ignored by the build system
/setup.cfg
app-engine
#+end_src

app.yaml reference is here [[https://cloud.google.com/appengine/docs/standard/reference/app-yaml?tab=python]].

#+header: :tangle app-engine/app.yaml
#+begin_src yaml
runtime: python39

handlers:
  # This configures Google App Engine to serve the files in the app's
  # static directory.
- url: /static
  static_dir: static

  # This handler routes all requests not caught above to your main
  # app. It is required when static routes are defined, but can be
  # omitted (along with the entire handlers section) when there are no
  # static files defined.
- url: /.*
  script: auto
#+end_src

Here's an updated main.py that pushes and pulls data from datastore.

#+header: :tangle app-engine/main.py
#+begin_src python
from google.cloud import datastore
import datetime
from flask import Flask, render_template

datastore_client = datastore.Client()

def store_time(dt):
    entity = datastore.Entity(key=datastore_client.key('visit'))
    entity.update({
        'timestamp': dt
    })

    datastore_client.put(entity)


def fetch_times(limit):
    query = datastore_client.query(kind='visit')
    query.order = ['-timestamp']

    times = query.fetch(limit=limit)

    return times

app = Flask(__name__)

@app.route('/')
def root():
    # Store the current access time in Datastore.
    store_time(datetime.datetime.now(tz=datetime.timezone.utc))

    # Fetch the most recent 10 access times from Datastore.
    times = fetch_times(10)

    return render_template(
        'index.html', times=times)

if __name__ == '__main__':
    # This is used when running locally only. When deploying to Google
    # App Engine, a webserver process such as Gunicorn will serve the
    # app. This can be configured by adding an `entrypoint` to
    # app.yaml.  Flask's development server will automatically serve
    # static files in the "static" directory. See:
    # http://flask.pocoo.org/docs/1.0/quickstart/#static-files. Once
    # deployed, App Engine itself will serve those files as configured
    # in app.yaml.
    app.run(host='127.0.0.1', port=8080, debug=True)
#+end_src

And here's an updated index.html

#+header: :tangle app-engine/templates/index.html
#+begin_src jinja2
<!doctype html>
<html>
  <head>
    <title>Datastore and Firebase Auth Example</title>
    <script src="{{ url_for('static', filename='script.js') }}"></script>
    <link type="text/css" rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  </head>
  <body>
    <h1>Datastore and Firebase Auth Example</h1>
    <h2>Last 10 visits</h2>
    {% for time in times %}
      <p>{{ time['timestamp'] }}</p>
    {% endfor %}
  </body>
</html>
#+end_src

#+header: :tangle app-engine/requirements.txt
#+begin_src text
Flask==2.1.0
google-cloud-datastore==2.7.1
#+end_src

Had to run the following to successfully connect to datastore:

#+begin_src sh
gcloud auth application-default login
GCLOUD_PROJECT=focal-disk-380217 ./app-engine/bin/python main.py
#+end_src

** Set up cloud SQL
:LOGBOOK:
CLOCK: [2023-04-07 Fri 14:12]--[2023-04-07 Fri 14:26] =>  0:14
:END:

* Implementation

** The frontend
:PROPERTIES:
:header-args: :mkdirp yes :comments link
:END:

“The frontend” implements the [[id:3021535E-D457-4E21-B296-4035BCE2E439][journey list view]], the [[id:89C5ADDA-6E9D-485B-877F-2A47D765789A][station list view]], and the [[id:8B7AC0C5-E098-401C-936F-9B8AA51B8AB4][single station view]].  Any features involving a viewable map will be offloaded to the [[id:30261BAC-BA61-4A98-AD03-ED6B8EFD3515][map frontend]].

The frontend will be implemented using Python with the [[https://trypyramid.com][Pyramid]] web application framework.  It *must* be served as a containerized application using Cloud run.

See the list of requirements by importance:

+ [[id:1659CF90-34E8-4D6B-BBC8-B347089D2089][Must]]
+ [[id:27D03FC8-96B7-4F0B-94C0-A1E027CBADB0][Should]]
+ Could
+ [[id:B1773244-DBCA-4154-92DB-54D718912754][Wish]]

*** Journey list view

#+header: :tangle hcbf/requirements.txt
#+begin_src text
Flask
psycopg2-binary
#+end_src

#+header: :tangle hcbf/main.py
#+begin_src python
from flask import Flask, render_template, request, redirect, url_for
import psycopg2
from psycopg2.extensions import AsIs
import sqlite3
import os
from journey import JourneyRecord
from abc import ABC, abstractmethod
from collections import namedtuple
from station import StationRecord

app = Flask(__name__)

class Database(ABC):
    @abstractmethod
    def get_journeys(self, offset, limit):
        return NotImplemented

    @abstractmethod
    def get_stations(self, offset, limit):
        return NotImplemented

    @abstractmethod
    def get_station(self, station_id):
        return NotImplemented

    @abstractmethod
    def get_station(self, station_id):
        return NotImplemented

    @abstractmethod
    def get_station_statistics(self, station_id):
        return NotImplemented

StationRecordPlus = namedtuple(
    'StationRecordPlus',
    'fid,finnish_name,finnish_address,returns,departures,x,y',
)

from dataclasses import dataclass

@dataclass
class StationStatistics:
    station_id: int
    total_returns: int
    total_departures: int
    average_return_distance: float
    average_departure_distance: float
    top_departures: list
    top_returns: list

class PostgreDB(Database):
    # postgre db contains an index (id)
    JourneyRecord = namedtuple(
        'JourneyRecord',
        'departure_time,return_time,departure_id,departure_name,return_id,return_name,distance,duration,id'
    )

    def __init__(self, database, user, password, host, port):
        self.database = database
        self.user = user
        self.password = password
        self.host = host
        self.port = port
        self.connection = psycopg2.connect(
            database=self.database,
            user=self.user,
            password=self.password,
            host=self.host,
            port=self.port
        )

    def get_journeys(self, page, page_size, search_term, order_by, direction):
        SQL = """
        SELECT * FROM journey
        WHERE    departure_station_name ILIKE %s ESCAPE ''
              OR return_station_name    ILIKE %s ESCAPE ''
        ORDER BY %s %s, id ASC
        LIMIT %s
        OFFSET %s
        """
        offset = (page - 1) * page_size
        search_term = f'%{search_term}%'
        order_by_mapping = {
            'departure_station': 'departure_station_name',
            'return_station': 'return_station_name',
            'distance': 'distance',
            'duration': 'duration'
        }
        order_by = order_by_mapping.get(order_by, 'id')
        direction = 'ASC' if direction == 'ascending' else 'DESC'
        with self.connection.cursor() as cursor:
            cursor.execute(SQL, (search_term, search_term, AsIs(order_by), AsIs(direction), page_size, offset))
            values = cursor.fetchall()
        return [PostgreDB.JourneyRecord._make(value) for value in values]

    def get_stations(self, page, page_size, search_term):
        SQL = """
        SELECT *
        FROM station
        WHERE    finnish_name    ILIKE %s ESCAPE ''
              OR finnish_address ILIKE %s ESCAPE ''
        ORDER BY fid ASC
        LIMIT %s
        OFFSET %s
        """
        offset = (page - 1) * page_size
        search_term = f'%{search_term}%'
        with self.connection.cursor() as cursor:
            cursor.execute(SQL, (search_term, search_term, page_size, offset))
            values = cursor.fetchall()
        return [StationRecord._make(value) for value in values]

    def get_station(self, station_id):
        SQL = """
        SELECT * from station
        WHERE fid = %s
        """
        with self.connection.cursor() as cursor:
            cursor.execute(SQL, (station_id,))
            value = cursor.fetchone()
        return StationRecord._make(value)

    def get_random_station_id(self):
        SQL = """
        SELECT fid from station
        ORDER BY RANDOM()
        LIMIT 1;
        """
        with self.connection.cursor() as cursor:
            cursor.execute(SQL)
            fid = cursor.fetchone()[0]
        return fid

    def get_station_statistics(self, station_id, months):
        total_journeys = self._total_journeys_from_and_to_station(station_id, months)
        avg_distances = self._avg_distances_from_and_to_station(station_id, months)
        top_return_stations = self._top_return_stations(station_id, months)
        top_departure_stations = self._top_departure_stations(station_id, months)
        stats = StationStatistics(
            station_id=station_id,
            total_returns=total_journeys[0],
            total_departures=total_journeys[1],
            average_return_distance=avg_distances[0],
            average_departure_distance=avg_distances[1],
            top_departures=top_departure_stations,
            top_returns=top_return_stations
        )

        return stats

    def _total_journeys_from_and_to_station(self, station_id, months):
        SQL = """
WITH station AS (
    SELECT *
    FROM station
    WHERE fid = %s
),
statistics AS (
    SELECT (
        SELECT id FROM station
    ), (
        SELECT COUNT(*)
        FROM journey
        JOIN station
        ON station.id = departure_station_id
        WHERE EXTRACT(MONTH FROM departure_time) IN %s
    ) as departures,
    ( SELECT COUNT(*)
        FROM journey
        JOIN station
        ON station.id = return_station_id
        WHERE EXTRACT(MONTH FROM departure_time) IN %s
    ) as returns
)
SELECT returns, departures
FROM station
JOIN statistics
ON station.id = statistics.id;
        """
        with self.connection.cursor() as cursor:
            cursor.execute(SQL, (station_id, months, months))
            value = cursor.fetchone()
        return value

    def _avg_distances_from_and_to_station(self, station_id, months):
        SQL = """
WITH station AS (
    SELECT *
    FROM station
    WHERE fid = %s
),
statistics AS (
    SELECT (
        SELECT id FROM station
    ), (
        SELECT AVG(distance) as average_departure_distance
        FROM journey
        JOIN station
        ON station.id = departure_station_id
        WHERE EXTRACT(MONTH FROM departure_time) IN %s
    ) as avg_departure_distance,
    (
        SELECT AVG(distance) as average_return_distance
        FROM journey
        JOIN station
        ON station.id = return_station_id
        WHERE EXTRACT(MONTH FROM departure_time) IN %s
    ) as avg_return_distance
)
SELECT avg_return_distance, avg_departure_distance
FROM station
JOIN statistics
ON station.id = statistics.id;
        """
        with self.connection.cursor() as cursor:
            cursor.execute(SQL, (station_id,months,months))
            value = cursor.fetchone()
        return value

    def _top_return_stations(self, station_id, months):
        SQL = """
WITH our_station AS (
     SELECT id
     FROM station
     WHERE fid = %s
)
SELECT return_station_id, return_station_name, COUNT(return_station_id)
FROM journey
JOIN our_station
ON journey.departure_station_id = our_station.id
WHERE EXTRACT(MONTH FROM departure_time) IN %s
GROUP BY return_station_name, journey.return_station_id
ORDER BY count DESC
LIMIT 5;
        """
        with self.connection.cursor() as cursor:
            cursor.execute(SQL, (station_id,months))
            values = cursor.fetchall()
        return values

    def _top_departure_stations(self, station_id, months):
        SQL = """
WITH our_station AS (
     SELECT id
     FROM station
     WHERE fid = %s
)
SELECT departure_station_id, departure_station_name, COUNT(return_station_id)
FROM journey
JOIN our_station
ON return_station_id = our_station.id
WHERE EXTRACT(MONTH FROM departure_time) IN %s
GROUP BY departure_station_name, departure_station_id
ORDER BY count DESC
LIMIT 5;
        """
        with self.connection.cursor() as cursor:
            cursor.execute(SQL, (station_id,months))
            values = cursor.fetchall()
        return values


@app.route('/journeys')
def journeys():
    page_size = 10
    # page indexing starts at 1
    page = max(1, int(request.args.get('page', '1')))
    search_term = request.args.get('search', '')
    order_by = request.args.get('order_by')
    direction = request.args.get('direction', 'ascending')
    pgdb = PostgreDB(
        os.environ['PSQL_DB'],
        os.environ['PSQL_USER'],
        os.environ['PSQL_PASS'],
        os.environ['PSQL_HOST'],
        os.environ['PSQL_PORT']
    )
    journeys = pgdb.get_journeys(page, page_size, search_term, order_by, direction)
    previous_page = None if page == 1 else page - 1
    next_page = page + 1
    return render_template(
       'journeys.html.j2',
        journeys=journeys,
        previous_page = previous_page,
        page = page,
        next_page = next_page,
        search_term=search_term,
        order_by=order_by,
        direction=direction
    )

@app.route('/stations')
def stations():
    page_size = 10
    page = max(1, int(request.args.get('page', '1')))
    search_term = request.args.get('search', '')
    db = PostgreDB(
        os.environ['PSQL_DB'],
        os.environ['PSQL_USER'],
        os.environ['PSQL_PASS'],
        os.environ['PSQL_HOST'],
        os.environ['PSQL_PORT']
    )
    stations = db.get_stations(page, page_size, search_term)
    previous_page = None if page == 1 else page - 1
    next_page = page + 1
    return render_template(
        'stations.html.j2',
        stations=stations,
        previous_page=previous_page,
        page=page,
        next_page=next_page,
        search_term=search_term
    )

@app.route('/station/<station_id>')
def station(station_id):
    months = request.args.getlist('month')
    if months == []:
        months = ('5', '6', '7')
    months = tuple(map(int, months))
    db = PostgreDB(
        os.environ['PSQL_DB'],
        os.environ['PSQL_USER'],
        os.environ['PSQL_PASS'],
        os.environ['PSQL_HOST'],
        os.environ['PSQL_PORT']
    )
    station = db.get_station(station_id)
    statistics = db.get_station_statistics(station_id, months)
    return render_template(
        'station.html.j2',
        station=station,
        statistics=statistics,
        months=months
    )

@app.route('/random-station')
def random_station():
    db = PostgreDB(
        os.environ['PSQL_DB'],
        os.environ['PSQL_USER'],
        os.environ['PSQL_PASS'],
        os.environ['PSQL_HOST'],
        os.environ['PSQL_PORT']
    )
    fid = db.get_random_station_id()
    return redirect(url_for('station', station_id=fid))

@app.route('/')
def home():
    return render_template('home.html.j2')

if __name__ == "__main__":
    app.run(host='0.0.0.0', port=8082, debug=True)
#+end_src

#+header: :tangle hcbf/templates/base.html.j2
#+begin_src jinja2
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link type="text/css" rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    {% block head_plus %}
    {% endblock head_plus %}
    <title>
      {% block title %}
        Helsinki city bikes
      {% endblock title %}
    </title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
  </head>
  <body>
    {% block navbar %}
      <nav class="navbar navbar-expand-lg bg-light">
        <div class="container-fluid">
          <a class="navbar-brand" href="#">Helsinki City Bikes</a>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
          </button>
          <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
              <li class="nav-item">
                <a class="nav-link" href="{{ url_for('home') }}">Home</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="{{ url_for('journeys') }}">Journeys</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="{{ url_for('stations') }}">Stations</a>
              </li>
            </ul>
          </div>
        </div>
      </nav>
    {% endblock navbar %}
    {% block content %}
      <p>Implement the content block</p>
    {% endblock content %}
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4" crossorigin="anonymous"></script>

    {% block body_plus %}
    {% endblock body_plus %}
  </body>
</html>
#+end_src

#+header: :tangle hcbf/templates/home.html.j2
#+begin_src jinja2
{% extends "base.html.j2" %}

{% block content %}
  <div class="container">
    <div class="row align-items-center">
      <div class="col d-flex justify-content-center">
        <p class="lead mt-5">
          Pick a table category from the top nav bar, or...
        </p>
      </div>
    </div>
    <div class="row align-items-center">
      <div class="col d-flex justify-content-center">
        <a class="btn btn-primary" href="{{ url_for('random_station') }}" role="button">Pick a random station</a>
      </div>
    </div>
  </div>
{% endblock %}
#+end_src

#+header: :tangle hcbf/templates/journeys.html.j2
#+begin_src jinja2
{% extends "base.html.j2" %}

{% block head_plus %}
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.4/font/bootstrap-icons.css">
{% endblock %}

{% block content %}
  <div class="container">
    <div class="row">
      <div class="col d-flex justify-content-center">
        <h1>Journeys</h1>
      </div>
    </div>
    <div class="row">
      <div class="col">
        <form>
          <div class="input-group" id="form">
            <input type="" class="form-control" placeholder="Search term" name="search" value="{{ search_term }}">
            <button type="submit" class="btn btn-primary">Search</button>
          </div>
        </form>
      </div>
    </div>
    <div class="row">
      <div class="col">
        <div class="table-responsive">
          <table class="table table-striped table-hover">
            <thead>
              <tr>
                <th>
                  {% if order_by == 'departure_station' %}
                    {% if direction == 'ascending' %}
                      <a href="{{ url_for('journeys', page=1, search=search_term, order_by='departure_station', direction='descending') }}">Departure station</a>
                      <i class="bi-sort-alpha-down"></i>
                    {% else %}
                      <a href="{{ url_for('journeys', page=1, search=search_term, order_by='departure_station', direction='ascending') }}">Departure station</a>
                      <i class="bi-sort-alpha-up"></i>
                    {% endif %}
                  {% else %}
                    <a href="{{ url_for('journeys', page=1, search=search_term, order_by='departure_station', direction='ascending') }}">Departure station</a>
                  {% endif %}
                </th>
                <th>
                  {% if order_by == 'return_station' %}
                    {% if direction == 'ascending' %}
                      <a href="{{ url_for('journeys', page=1, search=search_term, order_by='return_station', direction='descending') }}">Return station</a>
                      <i class="bi-sort-alpha-down"></i>
                    {% else %}
                      <a href="{{ url_for('journeys', page=1, search=search_term, order_by='return_station', direction='ascending') }}">Return station</a>
                      <i class="bi-sort-alpha-up"></i>
                    {% endif %}
                  {% else %}
                    <a href="{{ url_for('journeys', page=1, search=search_term, order_by='return_station', direction='ascending') }}">Return station</a>
                  {% endif %}
                </th>
                <th>
                  {% if order_by == 'distance' %}
                    {% if direction == 'ascending' %}
                      <a href="{{ url_for('journeys', page=1, search=search_term, order_by='distance', direction='descending') }}">Covered distance (km)</a>
                      <i class="bi-sort-numeric-down"></i>
                    {% else %}
                      <a href="{{ url_for('journeys', page=1, search=search_term, order_by='distance', direction='ascending') }}">Covered distance (km)</a>
                      <i class="bi-sort-numeric-up"></i>
                    {% endif %}
                  {% else %}
                    <a href="{{ url_for('journeys', page=1, search=search_term, order_by='distance', direction='ascending') }}">Covered distance (km)</a>
                  {% endif %}
                </th>
                <th>
                  {% if order_by == 'duration' %}
                    {% if direction == 'ascending' %}
                      <a href="{{ url_for('journeys', page=1, search=search_term, order_by='duration', direction='descending') }}">Duration (m)</a>
                      <i class="bi-sort-numeric-down"></i>
                    {% else %}
                      <a href="{{ url_for('journeys', page=1, search=search_term, order_by='duration', direction='ascending') }}">Duration (m)</a>
                      <i class="bi-sort-numeric-up"></i>
                    {% endif %}
                  {% else %}
                    <a href="{{ url_for('journeys', page=1, search=search_term, order_by='duration', direction='ascending') }}">Duration (m)</a>
                  {% endif %}
                </th>
              </tr>
            </thead>
            <tbody>
              {% for journey in journeys %}
                <tr>
                  <td>{{ journey.departure_name }}</td>
                  <td>{{ journey.return_name }}</td>
                  <td>{{ (journey.distance * 0.001) | round(1, 'floor') }}</td>
                  <td>{{ (journey.duration / 60) | int  }}</td>
                </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col d-flex justify-content-center">
        <ul class="pagination">
          <li class="page-item">
            <a
              class="page-link"
              href="{{ url_for('journeys', page=previous_page, search=search_term, order_by=order_by, direction=direction) }}">
              Previous
            </a>
          </li>
          <li class="page-item">
            <a
              class="page-link"
              href="#">
              {{ page }}
            </a>
          </li>
          <li class="page-item">
            <a class="page-link"
               href="{{ url_for('journeys', page=next_page, search=search_term, order_by=order_by, direction=direction) }}">
               Next
            </a>
          </li>
        </ul>
      </div>
    </div>
  </div>
{% endblock content %}
#+end_src

#+header: :tangle hcbf/templates/stations.html.j2
#+begin_src jinja2
{% extends "base.html.j2" %}

{% block content %}
  <div class="container">
    <div class="row">
      <div class="col d-flex justify-content-center">
        <h1>Stations</h1>
      </div>
    </div>
    <div class="row">
      <div class="col">
        <form>
          <div class="input-group">
            <input type="" class="form-control" placeholder="Search term" name="search" value="{{ search_term }}">
            <button type="submit" class="btn btn-primary">Search</button>
          </div>
        </form>
      </div>
    </div>
    <div class="row">
      <div class="col">
        <div class="table-responsive">
          <table class="table table-striped table-hover">
            <thead>
              <tr>
                <th>Name</th>
                <th>Address</th>
              </tr>
            </thead>
            <tbody>
              {% for station in stations %}
                <tr>
                  <td>
                    <a href="{{ url_for('station', station_id=station.fid) }}">
                      {{ station.finnish_name }}
                    </a>
                  </td>
                  <td>{{ station.finnish_address }}</td>
                </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col d-flex justify-content-center">
        <ul class="pagination">
          <li class="page-item">
            <a
              class="page-link"
              href="{{ url_for('stations', page=previous_page, search=search_term) }}">
              Previous
            </a>
          </li>
          <li class="page-item">
            <a
              class="page-link"
              href="#">
              {{ page }}
            </a>
          </li>
          <li class="page-item">
            <a class="page-link"
               href="{{ url_for('stations', page=next_page, search=search_term) }}">
               Next
            </a>
          </li>
        </ul>
      </div>
    </div>
  </div>
{% endblock content %}
#+end_src

#+header: :tangle hcbf/templates/station.html.j2
#+begin_src jinja2
{% extends "base.html.j2" %}

{% block content %}
  <div class="container">
    <div class="row">
      <div class="col-12 col-md-6">
        <div class="row">
          <div class="col">
            <h3>Station</h3>
            <table class="table">
              <thead>
                <tr>
                  <th>Name</th>
                  <th>Address</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>{{ station.finnish_name }}</td>
                  <td>{{ station.finnish_address }}</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <div class="row">
          <div class="col">
            <div class="row">
              <div class="col">
                <h3>Details</h3>
              </div>
            </div>
            <form>
              <input type="checkbox" class="btn-check" id="may" autocomplete="off" name="month" value="5"
                     {% if 5 in months %}
                       checked
                     {% endif %}>
              <label class="btn btn-outline-primary" for="may">May</label>

              <input type="checkbox" class="btn-check" id="june" autocomplete="off" name="month" value="6"
                     {% if 6 in months %}
                       checked
                     {% endif %}>
              <label class="btn btn-outline-primary" for="june">June</label>

              <input type="checkbox" class="btn-check" id="july" autocomplete="off" name="month" value="7"
                     {% if 7 in months %}
                       checked
                     {% endif %}>
              <label class="btn btn-outline-primary" for="july">July</label>

              <button type="submit" class="btn btn-primary">Recompute</button>
            </form>
            <table class="table">
              <thead>
                <tr>
                  <th>Journeys started here</th>
                  <th>Journeys ended here</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>{{ statistics.total_departures }}</td>
                  <td>{{ statistics.total_returns }}</td>
                </tr>
              </tbody>
              <thead>
                <tr>
                  <th>Average journey from here (m)</th>
                  <th>Average journey to here (m)</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>{{ statistics.average_departure_distance | int }}</td>
                  <td>{{ statistics.average_return_distance | int }}</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <div class="row">
          <div class="col">
            <h3>Top destinations</h3>
            <table class="table">
              <thead>
                <tr>
                  <th>Station</th>
                  <th>Journeys</th>
                </tr>
              </thead>
              <tbody>
                {% for journey in statistics.top_returns %}
                  <tr>
                    <td><a href="{{ url_for('station', station_id=journey[0]) }}">{{ journey[1] }}</a></td>
                    <td>{{ journey[2] }}</td>
                  </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>
        <div class="row">
          <div class="col">
            <h3>Top origins</h3>
            <table class="table">
              <thead>
                <tr>
                  <th>Station</th>
                  <th>Journeys</th>
                </tr>
              </thead>
              <tbody>
                {% for journey in statistics.top_departures %}
                  <tr>
                    <td><a href="{{ url_for('station', station_id=journey[0]) }}">{{ journey[1] }}</a></td>
                    <td>{{ journey[2] }}</td>
                  </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>
      </div>
      <div class="col-12 col-md-6">
        <div id="osm-map"></div>
      </div>
    </div>
  </div>
{% endblock content %}

{% block body_plus %}
  <script>
    x = {{ station.x }}
    y = {{ station.y }}
  </script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
  <script src="{{ url_for('static', filename="osm.js") }}"></script>
{% endblock body_plus %}
#+end_src

#+header: :tangle hcbf/static/osm.js
#+begin_src js
// Where you want to render the map.
var element = document.getElementById('osm-map');

// Height has to be set. You can do this in CSS too.
element.style = 'height:max(100%, 400px);'

// Create Leaflet map on map element.
var map = L.map(element);

// Add OSM tile layer to the Leaflet map.
L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
}).addTo(map);

var target = L.latLng(y, x);

map.setView(target, 13);

L.marker(target)
  .addTo(map);
#+end_src

#+header: :tangle hcbf/static/style.css
#+begin_src css

#+end_src

We reuse the little parser classes I wrote when [[id:8FAC00D2-5DBC-4127-B7F6-EE8244DEAF7A][exploring the dataset]].

#+header: :tangle hcbf/journey.py
#+header: :noweb yes
#+begin_src python
<<JourneyParser>>
#+end_src

#+header: :tangle hcbf/station.py
#+header: :noweb yes
#+begin_src python
<<StationTypes>>
#+end_src

** The backend

** The database

** The datapump

** The map frontend
:PROPERTIES:
:ID:       30261BAC-BA61-4A98-AD03-ED6B8EFD3515
:END:
