#+todo: TODO | DONE
#+property: header-args :mkdirp yes

* Table of contents                                                     :TOC:
- [[#this-app][This app]]
- [[#running-locally-with-docker][Running locally with Docker]]
  - [[#download-and-extract-the-source-tarballs][Download and extract the source tarballs]]
  - [[#define-a-docker-network][Define a Docker network]]
  - [[#run-up-a-postgresql-database][Run up a PostgreSQL database]]
  - [[#declare-the-database][Declare the database]]
  - [[#populate-the-database][Populate the database]]
  - [[#run-up-the-backend][Run up the backend]]
  - [[#run-up-the-frontend][Run up the frontend]]
- [[#cleaning-up][Cleaning up]]
- [[#sources][Sources]]
  - [[#the-database][The database]]
    - [[#sql-statements][SQL statements]]
    - [[#database-prep-script][Database prep script]]
  - [[#the-data-import][The data import]]
    - [[#mainpy][main.py]]
    - [[#requirementstxt][requirements.txt]]
    - [[#stations-data-import][Stations data import]]
    - [[#journeys-data-import][Journeys data import]]
  - [[#the-backend][The backend]]
    - [[#unit-tests-for-backend][Unit tests for backend]]
    - [[#requirementstxt-1][requirements.txt]]
    - [[#logic-layer][Logic layer]]
    - [[#presentation-layer][Presentation layer]]
    - [[#datastore-layer][Datastore layer]]
    - [[#mainpy-1][main.py]]
  - [[#the-frontend][The frontend]]
    - [[#tests-for-frontend][Tests for frontend]]
    - [[#requirementstxt-2][requirements.txt]]
    - [[#the-application-entrypoint-mainpy][The application entrypoint (main.py)]]
    - [[#html-templates][HTML templates]]
    - [[#osmjs][osm.js]]
    - [[#stylecss][style.css]]
- [[#google-cloud][Google Cloud]]
  - [[#dispatchyaml][dispatch.yaml]]
  - [[#services][Services]]
    - [[#default][default]]
    - [[#frontend-configuration][Frontend configuration]]
    - [[#backend-configuration][Backend configuration]]
    - [[#database-export][Database export]]

* This app

HCB is a set of software for exploring data related to Helsinki city bikes.

In the beginning it was a Python program that queried an SQLite3 database and rendered HTML over HTTP.  Due to the project requirements, the app was separated in to three components: a PostgreSQL database, a backend, and a frontend.

The backend is implemented in Python using [[https://flask-restful.readthedocs.io/en/latest/index.html][flask_restful]].  It consumes and produces HTTP messages.  The data source used is a PostgreSQL database.

The frontend is implemented in Python using [[https://flask.palletsprojects.com][Flask]].  It interfaces between a client (web browser) and the backend over HTTP.

There are also two additional Python programs, one for initializing the database, and another for seeding the database with data provided in the assignment.


There is a set of unit tests for the backend. See [[#unit-tests-for-backend][Unit tests for backend]].  There are E2E tests for the frontend.  See [[#tests-for-frontend][Tests for frontend]].

An instance of the app is running at [[https://hcb.rkll.net]].

* Running locally with Docker

Here are short instructions for setting up the app locally.

Prerequisites:

+ A browser and an archive extractor, or =curl= and =tar=
+ A container engine like [[https://www.docker.com][Docker]].  The engine's VM should have access to at least 4GB because the data import operation is a memory hog.

Note that I used [[https://podman.io][Podman]] instead of Docker as the container engine.  Podman should share the same API as Docker, but I know from experience that this is not always true.

If you run into issues with docker:

+ Install podman, which is available in your Linux distros package archive
+ alias docker to podman in your shell (=alias docker=podman=)

** Download and extract the source tarballs

Latest sources are available here: [[https://storage.googleapis.com/hcb-helsinki-city-bikes/main/sources.tar]].  Download and extract them, below is a an example command.  Make a note of the extracted directories, they will be referenced later in the [[#running-locally-with-docker][Running locally with Docker]] section.

#+begin_src sh
curl https://storage.googleapis.com/hcb-helsinki-city-bikes/main/sources.tar \
    | tar xv
#+end_src

Alternatively, if you have Emacs installed on your machine, open this file in Emacs and run the command =M-x org-babel-tangle=.

The extracted archive contains a =setup.sh= script that you may execute (=./setup.sh=), or follow along with the instructions below.  Cleanup may be performed with the =cleanup.sh= script.

** Define a Docker network

Set up a Docker network.  This allows the networked components to talk to each other.

#+header: :tangle setup.sh
#+header: :shebang #!/bin/bash
#+header: :comments org
#+begin_src bash
docker network create hcb
#+end_src

** Run up a PostgreSQL database

Here’s a Docker command to create an instance of PostgreSQL.  If you have not yet done so, first [[#define-a-docker-network][define a Docker network]].

#+header: :tangle setup.sh
#+header: :comments org
#+begin_src bash
docker run --rm --detach \
       --name=hcb-postgres \
       --network=hcb \
       --publish 5432:5432 \
       --env POSTGRES_PASSWORD=postgres \
       postgres
#+end_src

** Declare the database

A [[#the-database][Python script]] for this step is untarred to =hcb-setup-database= directory.  The directory contains a Dockerfile.  Build and run it.  There is a provided env file, =docker.env=, which may be tweaked to fit your environment.

#+header: :tangle setup.sh
#+header: :comments org
#+begin_src bash
pushd hcb-setup-database
docker build --tag=hcb-setup-database .
docker run --rm --tty \
       --network=hcb \
       --env-file=docker.env \
       hcb-setup-database
popd
#+end_src

Here is the =Dockerfile= and the =docker.env= files for reference.

#+header: :tangle hcb-setup-database/Dockerfile
#+begin_src dockerfile
FROM python:3.11-slim
WORKDIR /app
ADD requirements.txt .
RUN pip install -r requirements.txt
ADD main.py .
CMD python main.py
#+end_src

#+header: :tangle hcb-setup-database/docker.env
#+begin_src conf
PSQL_USERNAME=postgres
PSQL_PASSWORD=postgres
PSQL_HOST=hcb-postgres
PSQL_PORT=5432
#+end_src

** Populate the database

The [[#data-import][data import]] job is untarred to =hcb-data-import= directory.  There is a Dockerfile that you can build and run.  This is a bit of a memory hog.  2GB of system memory doesn't seem to cut it.  If you get =Killed= while processing, increase Docker's allocated memory to 4096MB.

#+header: :tangle setup.sh
#+header: :comments org
#+begin_src bash
pushd hcb-data-import
docker build --tag=hcb-data-import .
docker run --rm --tty \
       --network=hcb \
       --env-file=docker.env \
       hcb-data-import
popd
#+end_src

Here is the =Dockerfile= and the =docker.env= for reference.

#+header: :tangle hcb-data-import/Dockerfile
#+begin_src dockerfile
FROM python:3.11-slim
WORKDIR /app
ADD requirements.txt .
RUN pip install -r requirements.txt
ADD main.py .
ADD stations.py .
ADD journeys.py .
CMD python main.py
#+end_src

#+header: :tangle hcb-data-import/docker.env
#+begin_src conf
HCBI_JOURNEY_SOURCES=https://dev.hsl.fi/citybikes/od-trips-2021/2021-05.csv,https://dev.hsl.fi/citybikes/od-trips-2021/2021-06.csv,https://dev.hsl.fi/citybikes/od-trips-2021/2021-07.csv
HCBI_STATION_SOURCE=https://opendata.arcgis.com/datasets/726277c507ef4914b0aec3cbcfcbfafc_0.csv
PSQL_DATABASE=hcb
PSQL_USERNAME=postgres
PSQL_PASSWORD=postgres
PSQL_HOST=hcb-postgres
PSQL_PORT=5432
#+end_src

** Run up the backend

[[#the-backend][The backend]] is untarred to =hcb-backend=.  Again, there is a =Dockerfile= and a =docker.env= provided.  Here's how you would build and run the container:

#+header: :tangle setup.sh
#+header: :comments org
#+begin_src bash
pushd hcb-backend
docker build --tag=hcb-backend .
docker run --rm --detach \
       --network=hcb \
       --name=hcb-backend \
       --env-file=docker.env \
       --publish 5433:5433 \
       hcb-backend
popd
#+end_src

To verify the backend is able to connect to PostgreSQL and serve requests, try performing a HTTP GET on one of the endpoints:
+ =/journeys=
+ =/stations=
+ =/stations/random=

Something like this should work:

#+begin_src sh
curl http://localhost:5433/journeys?page_size=5
#+end_src

Here are the =Dockerfile= and =docker.env= file, as a reference.

#+header: :tangle hcb-backend/Dockerfile
#+begin_src dockerfile
FROM python:3.11-slim
WORKDIR /app
ADD requirements.txt .
RUN pip install -r requirements.txt
ADD main.py .
ADD hcb hcb
CMD python main.py
#+end_src

#+header: :tangle hcb-backend/docker.env
#+begin_src conf
PSQL_DB=hcb
PSQL_USER=postgres
PSQL_PASS=postgres
PSQL_HOST=hcb-postgres
PSQL_PORT=5432
HCBB_HOST=0.0.0.0
HCBB_PORT=5433
HCBB_SET_HTTP_CACHE_HEADERS=False
HCBB_CACHE_MAX_AGE=3600
#+end_src

** Run up the frontend

[[#the-frontend][The frontend]] is untarred to =hcb-frontend=.  Build and run it.

#+header: :tangle setup.sh
#+header: :comments org
#+begin_src bash
pushd hcb-frontend
docker build -t hcb-frontend .
docker run --rm --detach \
       --network=hcb \
       --name=hcb-frontend \
       --env-file=docker.env \
       --publish=5434:5434 \
       hcb-frontend
popd
#+end_src

To verify everything is working, visit [[http://127.0.0.1:5434/]] using your browser.

Once again, here are the =Dockerfile= and =docker.env= for reference.

#+header: :tangle hcb-frontend/Dockerfile
#+begin_src dockerfile
FROM python:3.11-slim
WORKDIR /app
ADD requirements.txt .
RUN pip install -r requirements.txt
ADD main.py .
COPY templates/ templates/
COPY static/ static/
CMD python main.py
#+end_src

#+header: :tangle hcb-frontend/docker.env
#+begin_src conf
HCBF_HOST=0.0.0.0
HCBF_PORT=5434
HCBF_BACKEND_URL=http://hcb-backend:5433
HCBF_SET_HTTP_CACHE_HEADERS=False
HCBF_CACHE_MAX_AGE=3600
#+end_src

* Cleaning up

Run the following commands to remove docker images, containers and networks related to this project:

#+header: :tangle cleanup.sh
#+header: :shebang #!/bin/bash
#+header: :comments org
#+begin_src bash
docker network rm --force hcb
docker rmi hcb-frontend hcb-backend hcb-data-import hcb-setup-database
#+end_src

* Sources

** The database

/The database/ is a PostgreSQL database.  Here are the SQL statements that prepare it.  See the section [[#declare-the-database][Declare the database]] for setup instructions.

*** SQL statements

#+name: create-database-stmt
#+begin_src sql
CREATE DATABASE hcb;
#+end_src

#+name: create-journey-stmt
#+begin_src sql
BEGIN;

CREATE TABLE journey (
       id SERIAL PRIMARY KEY,
       departure_time TIMESTAMP,
       return_time TIMESTAMP,
       departure_station_id TEXT,
       departure_station_name TEXT,
       return_station_id TEXT,
       return_station_name TEXT,
       distance FLOAT,
       duration INTEGER
);

-- We need to sort filter and search on the following columns
CREATE INDEX distance_index
ON journey(distance);

CREATE INDEX duration_index
ON journey(duration);

CREATE INDEX departure_station_name_index
ON journey(departure_station_name);

CREATE INDEX return_station_name_index
ON journey(return_station_name);

CREATE INDEX journey_departure_station_id_index
ON journey(departure_station_id);

CREATE INDEX journey_return_station_id_index
ON journey(return_station_id);

COMMIT;
#+end_src

#+name: create-station-stmt
#+begin_src sql
CREATE TABLE  station (
       fid INTEGER PRIMARY KEY,
       id TEXT,
       finnish_name TEXT,
       swedish_name TEXT,
       english_name TEXT,
       finnish_address TEXT,
       swedish_address TEXT,
       finnish_city TEXT,
       swedish_city TEXT,
       operator TEXT,
       capacity INTEGER,
       x FLOAT,
       y FLOAT
);
#+end_src

*** Database prep script

A python script provided below prepares the database for use.  Execution instructions are provided in the section [[#declare-the-database][Declare the database]].

**** requirements.txt

#+header: :tangle hcb-setup-database/requirements.txt
#+begin_src text
psycopg2-binary
#+end_src

**** main.py

#+header: :noweb yes
#+header: :tangle hcb-setup-database/main.py
#+begin_src python
import psycopg2
import os

psql_user = os.environ['PSQL_USERNAME']
psql_pass = os.environ['PSQL_PASSWORD']
psql_host = os.environ['PSQL_HOST']
psql_port = os.environ['PSQL_PORT']

connection = psycopg2.connect(
    database='postgres',
    user=psql_user,
    password=psql_pass,
    host=psql_host,
    port=psql_port
)
connection\
    .set_isolation_level(
        psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT
    )
with connection.cursor() as cursor:
    cursor.execute(
        """
<<create-database-stmt>>
        """
    )

connection.close()

connection = psycopg2.connect(
    database='hcb',
    user=psql_user,
    password=psql_pass,
    host=psql_host,
    port=psql_port
)
connection.autocommit = False

with connection.cursor() as cursor:
    cursor.execute(
        """
<<create-journey-stmt>>
        """
    )
    cursor.execute(
        """
<<create-station-stmt>>
        """
    )

print('OK')
#+end_src

** The data import

Data import reads journey and station data from the internet.  This component has two separate pieces:
+ Journey import
+ Station import
Which are glued together in main.py.

*** main.py

#+header: :tangle hcb-data-import/main.py
#+begin_src python
import journeys
import stations

if __name__ == "__main__":
    stations.main()
    journeys.main()
#+end_src

*** requirements.txt

#+header: :tangle hcb-data-import/requirements.txt :mkdirp yes
#+begin_src text
psycopg2-binary
requests
#+end_src

*** Stations data import

This is the part of data import that downloads station data, and pushes it to a PostgreSQL database instance.

#+header: :tangle hcb-data-import/stations.py
#+begin_src python
import os
import requests
from collections import namedtuple
import csv
import json
import psycopg2

psql_database = os.environ['PSQL_DATABASE']
psql_user = os.environ['PSQL_USERNAME']
psql_password = os.environ['PSQL_PASSWORD']
psql_host = os.environ['PSQL_HOST']
psql_port = os.environ['PSQL_PORT']
station_sources = os.environ['HCBI_STATION_SOURCE']

def download_network_file(networkfile):
    """Download a csv from the net, write to local site.

    Return local file's path.

    """

    localpath = os.path.abspath(
        os.path.join(
            '.',
            os.path.basename(networkfile)
        )
    )

    if os.path.exists(localpath):
        print(f'file {localpath} exists, not redownloading')
    else:
        print(f'downloading {networkfile}',
              f'to {localpath}', sep='\n')

        with open(localpath, 'w') as localfile:
            response = requests.get(networkfile)
            response.raise_for_status()
            # Server doesn't set charset=utf-8 because it is dumb
            response.encoding = 'utf-8'
            localfile.write(response.text)

    return localpath

StationTuple = namedtuple(
    'StationTuple',
    'fid,'
    'id,'
    'finnish_name,'
    'swedish_name,'
    'english_name,'
    'finnish_address,'
    'swedish_address,'
    'finnish_city,'
    'swedish_city,'
    'operator,'
    'capacity,'
    'x,'
    'y'
)

class Station:
    def __init__(
            self,
            fid,
            id,
            finnish_name,
            swedish_name,
            english_name,
            finnish_address,
            swedish_address,
            finnish_city,
            swedish_city,
            operator,
            capacity,
            x,
            y
    ):
        self.fid = fid
        self.id = id
        self.finnish_name = finnish_name
        self.swedish_name = swedish_name
        self.english_name = english_name
        self.finnish_address = finnish_address
        self.swedish_address = swedish_address
        self.finnish_city = finnish_city
        self.swedish_city = swedish_city
        self.operator = operator
        self.capacity = capacity
        self.x = x
        self.y = y

    @staticmethod
    def from_dict(dct):
        return Station(**dct)

    def to_dict(self):
        return {
            'fid': self.fid,
            'id': self.id,
            'finnish_name': self.finnish_name,
            'swedish_name': self.swedish_name,
            'english_name': self.english_name,
            'finnish_address': self.finnish_address,
            'swedish_address': self.swedish_address,
            'finnish_city': self.finnish_city,
            'swedish_city': self.swedish_city,
            'operator': self.operator,
            'capacity': self.capacity,
            'x': self.x,
            'y': self.y
        }

    def __repr__(self):
        return (
            'Station('
            f'{str(self.fid)!r}, '
            f'{self.id!r}, '
            f'{self.finnish_name!r}, '
            f'{self.swedish_name!r}, '
            f'{self.english_name!r}, '
            f'{self.finnish_address!r}, '
            f'{self.swedish_address!r}, '
            f'{self.finnish_city!r},'
            f'{self.swedish_city!r},'
            f'{self.operator!r},'
            f'{str(self.capacity)!r},'
            f'{str(self.x)!r},'
            f'{str(self.y)!r}'
            ')'
        )

    @property
    def y(self):
        return self._y

    @y.setter
    def y(self, y):
        if isinstance(y, str):
            y = float(y)

        if not isinstance(y, float):
            raise TypeError('y must be a float')
        self._y = y


    @property
    def x(self):
        return self._x

    @x.setter
    def x(self, x):
        if isinstance(x, str):
            x = float(x)

        if not isinstance(x, float):
            raise TypeError('x must be a float')
        self._x = x

    @property
    def capacity(self):
        return self._capacity

    @capacity.setter
    def capacity(self, capacity):
        if isinstance(capacity, str):
            capacity = int(capacity)

        if not isinstance(capacity, int):
            raise TypeError('capacity must be an int')
        self._capacity = capacity

    @property
    def operator(self):
        return self._operator

    @operator.setter
    def operator(self, operator):
        if isinstance(operator, str):
            operator = operator.strip()
            if len(operator) == 0:
                operator = None

        if not (operator is None
                or isinstance(operator, str)):
            raise TypeError('operator must be a str or None')
        self._operator = operator


    @property
    def swedish_city(self):
        return self._swedish_city

    @swedish_city.setter
    def swedish_city(self, swedish_city):
        if isinstance(swedish_city, str):
            swedish_city = swedish_city.strip()
            if len(swedish_city) == 0:
                swedish_city = None

        if not (swedish_city is None
                or isinstance(swedish_city, str)):
            raise TypeError('swedish_city must be a str or None')
        self._swedish_city = swedish_city


    @property
    def finnish_city(self):
        return self._finnish_city

    @finnish_city.setter
    def finnish_city(self, finnish_city):
        if isinstance(finnish_city, str):
            finnish_city = finnish_city.strip()
            if len(finnish_city) == 0:
                finnish_city = None

        if not (finnish_city is None
                or isinstance(finnish_city, str)):
            raise TypeError('finnish_city must be a str or None')
        self._finnish_city = finnish_city

    @property
    def swedish_address(self):
        return self._swedish_address

    @swedish_address.setter
    def swedish_address(self, swedish_address):
        if isinstance(swedish_address, str):
            swedish_address = swedish_address.strip()
            if len(swedish_address) == 0:
                swedish_address = None

        if not (swedish_address is None
                or isinstance(swedish_address, str)):
            raise TypeError('swedish_address must be a str or None')
        self._swedish_address = swedish_address


    @property
    def finnish_address(self):
        return self._finnish_address

    @finnish_address.setter
    def finnish_address(self, finnish_address):
        if isinstance(finnish_address, str):
            finnish_address = finnish_address.strip()
            if len(finnish_address) == 0:
                finnish_address = None

        if not (finnish_address is None
                or isinstance(finnish_address, str)):
            raise TypeError('finnish_address must be a str or None')
        self._finnish_address = finnish_address

    @property
    def english_name(self):
        return self._english_name

    @english_name.setter
    def english_name(self, english_name):
        if isinstance(english_name, str):
            english_name = english_name.strip()
            if len(english_name) == 0:
                english_name = None


        if not (english_name is None
                or isinstance(english_name, str)):
            raise TypeError('english_name must be a str or None')
        self._english_name = english_name

    @property
    def swedish_name(self):
        return self._swedish_name

    @swedish_name.setter
    def swedish_name(self, swedish_name):
        if isinstance(swedish_name, str):
            swedish_name = swedish_name.strip()
            if len(swedish_name) == 0:
                swedish_name = None

        if not (swedish_name is None
                or isinstance(swedish_name, str)):
            raise TypeError('swedish_name must be a str or None')
        self._swedish_name = swedish_name

    @property
    def finnish_name(self):
        return self._finnish_name

    @finnish_name.setter
    def finnish_name(self, finnish_name):
        if isinstance(finnish_name, str):
            finnish_name = finnish_name.strip()
            if len(finnish_name) == 0:
                finnish_name = None

        if not (finnish_name is None
                or isinstance(finnish_name, str)):
            raise TypeError('finnish_name must be a str or None')
        self._finnish_name = finnish_name

    @property
    def id(self):
        return self._id

    @id.setter
    def id(self, id):
        if not isinstance(id, str):
            raise TypeError('id must be a str')
        self._id = id

    @property
    def fid(self):
        return self._fid

    @fid.setter
    def fid(self, fid):
        if isinstance(fid, str):
            fid = int(fid)
        if not isinstance(fid, int):
            raise TypeError('fid must be an int')
        self._fid = fid

def parse_entries(filepath):
    reader = csv.reader(open(filepath, newline=''))
    # skip header
    next(reader)
    success, fail = [], []
    for entry in reader:
        tup = StationTuple._make(entry)
        try:
            success.append(Station(*tup).to_dict())
        except Exception as e:
            fail.append({ 'error': str(e), 'entry': entry })
    return success, fail

def download_and_filter(networkfile):
    """Download and process station data into a json file.

    Download the network files to site.  Return a filepath containing
    downloaded data.

    """

    resultpath = os.path.abspath(
        os.path.join('.', 'stations.json')
    )

    if os.path.exists(resultpath):
        print(f'{resultpath} exists, not redownloading')
        return resultpath
    file = download_network_file(networkfile)
    success, fails = parse_entries(file)
    json.dump(success, open('stations.json', 'w'), indent=4)
    json.dump(fails, open('bad-data.json', 'w'), indent=4)
    return 'stations.json'


def push_to_sql(stationpath):
    with open(stationpath, 'r') as fp:
        stations = [
            Station.from_dict(dct) for dct in json.load(fp)
        ]

    connection = psycopg2.connect(
        database=psql_database,
        user=psql_user,
        password=psql_password,
        host=psql_host,
        port=psql_port
    )

    insert_statement = """
INSERT INTO station (
    fid,
    id,
    finnish_name,
    swedish_name,
    english_name,
    finnish_address,
    swedish_address,
    finnish_city,
    swedish_city,
    operator,
    capacity,
    x,
    y
)
VALUES (
    %(fid)s,
    %(id)s,
    %(finnish_name)s,
    %(swedish_name)s,
    %(english_name)s,
    %(finnish_address)s,
    %(swedish_address)s,
    %(finnish_city)s,
    %(swedish_city)s,
    %(operator)s,
    %(capacity)s,
    %(x)s,
    %(y)s
)
    """
    with connection.cursor() as cursor:
        for station in stations:
            dct = station.to_dict()
            cursor.execute(insert_statement, dct)
    connection.commit()
    print('done')
    connection.close()

def main():
    stationpath = \
        download_and_filter(station_sources)
    push_to_sql(stationpath)

if __name__ == "__main__":
    main()
#+end_src

*** Journeys data import

Functional requirements for the data import are:
+ Don't import journeys that lasted < 10 seconds
+ Don't import journeys that covered < 10 meters

Here are some additional requirements I defined for the import process:
+ Some journeys were either abnormally long in duration or distance.  Filter out any journeys that are:
  + longer than 6 hours
  + longer than 150 kilometers
+ Almost all journeys were duplicated in the CSV's.  Delete duplicate entries.

#+header: :tangle hcb-data-import/journeys.py :mkdirp yes
#+begin_src python
import requests
import os
from io import StringIO
import csv
from collections import namedtuple
from datetime import datetime
import json
import psycopg2
from psycopg2.extras import execute_batch

journey_sources = os.environ['HCBI_JOURNEY_SOURCES'].split(',')
psql_database = os.environ['PSQL_DATABASE']
psql_user = os.environ['PSQL_USERNAME']
psql_password = os.environ['PSQL_PASSWORD']
psql_host = os.environ['PSQL_HOST']
psql_port = os.environ['PSQL_PORT']

print(journey_sources)
def download_network_files(networkfiles):
    """Downloads csv's from the net and writes to site's disk.

    networkfiles is a list of network files.

    Returns local file paths if successful.

    """

    paths = []
    for networkpath in networkfiles:
        localpath = os.path.abspath(
            os.path.join(
                '.',
                os.path.basename(networkpath),
            )
        )

        if os.path.exists(localpath):
            print(f'file {localpath} exists, so not redownloading')
        else:
            print(f'Downloading: {networkpath}',
                  f'to: {localpath}', sep='\n')

            with open(localpath, 'w') as localfile:
                # some weird interaction causes this request to fail
                # inside a Docker container, if certificates are
                # verified
                response = requests.get(
                    networkpath,
                    verify=False,
                )
                response.raise_for_status()
                localfile.write(response.text)
        paths.append(localpath)
    return paths

def delete_dups(entries):
    """Delete duplicates in a list of entries.

    Returns a list containing only unique entries.

    """
    return list(set(entries))

def merge_entries(filepaths):
    """Merge entries from multiple csv filepaths into one.

    Deletes a header line from each file.

    """
    entries = []
    for path in filepaths:
        with open(path, 'r') as fp:
            next(fp)
            for line in fp:
                entries.append(line)
    return entries

JourneyTuple = namedtuple(
        'JourneyTuple',
        'departure_time,'
        'return_time,'
        'departure_station_id,'
        'departure_station_name,'
        'return_station_id,'
        'return_station_name,'
        'distance,'
        'duration'
    )

class Journey:

    def __init__(
            self,
            departure_time,
            return_time,
            departure_station_id,
            departure_station_name,
            return_station_id,
            return_station_name,
            distance,
            duration
    ):
        self.departure_time = departure_time
        self.return_time = return_time
        self.departure_station_id = departure_station_id
        self.departure_station_name = departure_station_name
        self.return_station_id = return_station_id
        self.return_station_name = return_station_name
        self.distance = distance
        self.duration = duration

    @property
    def duration(self):
        return self._duration

    @duration.setter
    def duration(self, duration):
        if isinstance(duration, str):
            duration = int(duration)
        if not isinstance(duration, int):
            raise TypeError('duration must be an int or str')
        if duration < 10:
            raise ValueError('duration must be ≥ 10 seconds')
        # duration can't be longer than 6 hours
        if duration > 60 * 60 * 6:
            raise ValueError(
                'duration must be shorter than 6 hours'
            )
        self._duration = duration

    @property
    def distance(self):
        return self._distance

    @distance.setter
    def distance(self, distance):
        if isinstance(distance, str):
            distance = float(distance)
        if not isinstance(distance, float):
            raise TypeError('distance must be a float')
        if distance < 10:
            raise ValueError('distance must be ≥ 10 meters')
        if distance > 150_000:
            raise ValueError('distance must be ≤ 150km')
        self._distance = distance

    @property
    def return_station_name(self):
        return self._return_station_name

    @return_station_name.setter
    def return_station_name(self, return_station_name):
        if not isinstance(return_station_name, str):
            raise TypeError('return_station_name must be str')
        self._return_station_name = return_station_name

    @property
    def return_station_id(self):
        return self._return_station_id

    @return_station_id.setter
    def return_station_id(self, return_station_id):
        # These may start with a leading 0
        if not isinstance(return_station_id, str):
            raise TypeError('return_station_id must be str')
        self._return_station_id = return_station_id


    @property
    def departure_station_name(self):
        return self._departure_station_name

    @departure_station_name.setter
    def departure_station_name(self, departure_station_name):
        if not isinstance(departure_station_name, str):
            raise TypeError(
                'departure_station_name must be a str'
            )
        self._departure_station_name = departure_station_name

    @property
    def departure_station_id(self):
        return self._departure_station_id

    @departure_station_id.setter
    def departure_station_id(self, departure_station_id):
        if not isinstance(departure_station_id, str):
            raise TypeError(
                'departure_station_id must be a str'
            )
        self._departure_station_id = \
            departure_station_id

    @property
    def return_time(self):
        return self._return_time

    @return_time.setter
    def return_time(self, return_time):
        if isinstance(return_time, str):
            return_time = datetime.fromisoformat(return_time)
        if not isinstance(return_time, datetime):
            raise TypeError('return_time must be a str')
        self._return_time = return_time

    @property
    def departure_time(self):
        return self._departure_time

    @departure_time.setter
    def departure_time(self, departure_time):
        if isinstance(departure_time, str):
            departure_time = \
                datetime.fromisoformat(departure_time)
        if not isinstance(departure_time, datetime):
            raise TypeError('departure_time must be a str')
        self._departure_time = departure_time

    def to_dict(self):
        return {
            'departure_time': str(self.departure_time),
            'return_time': str(self.return_time),
            'departure_station_id': self.departure_station_id,
            'departure_station_name': \
            self.departure_station_name,
            'return_station_id': self.return_station_id,
            'return_station_name': self.return_station_name,
            'distance': self.distance,
            'duration': self.duration
        }

    @staticmethod
    def from_dict(dct):
        return Journey(**dct)

    def __repr__(self):
        return (
            'Journey('
            f'{str(self.departure_time)!r}, '
            f'{str(self.return_time)!r}, '
            f'{self.departure_station_id!r}, '
            f'{self.departure_station_name!r}, '
            f'{self.return_station_id!r}, '
            f'{self.return_station_name!r}, '
            f'{self.distance!r}, '
            f'{self.duration!r}'
            ')'
        )

def parse_entries(entries):
    """Parse a list of str entries in csv form.

    Return a tuple of successfully parsed entries, and entries which failed
    parsing.

    """
    success, fail = [], []
    for entry in entries:
        io = StringIO(entry)
        reader = csv.reader(io)
        value = JourneyTuple._make(next(reader))
        try:
            success.append(Journey(*value).to_dict())
        except Exception as e:
            fail.append({ 'error': str(e), 'entry': entry })
    return success, fail

def download_and_filter(networkfiles):
    """Download and process network files.

    Download network files to current site.  Remove any duplicate
    entries.  Filter bad entries.  Write result to site.  Return the
    filepath.

    """

    resultpath = os.path.abspath(
        os.path.join('.', 'journeys.json'),
    )
    if os.path.exists(resultpath):
        print(f'{resultpath} exists, not downloading network files')
        return resultpath

    files = download_network_files(networkfiles)
    collection = merge_entries(files)
    print(f'{len(collection)} entries')
    uniq = delete_dups(collection)
    print(f'{len(uniq)} unique entries')
    success, fails = parse_entries(uniq)
    print(f'{len(success)} parseable and validated entries')
    json.dump(fails, open('bad-entries.json', 'w'), indent=4)
    json.dump(success, open('journeys.json', mode='w'), indent=4)
    return 'journeys.json'

def push_to_sql(journeypath):
    """Load journeys from journeypath.

    Write journeys to a postgresql database.

    """
    with open(journeypath, 'r') as fp:
        journeys = [
            Journey.from_dict(dct).to_dict() for dct in json.load(fp)
        ]

    connection = psycopg2.connect(
        database=psql_database,
        user=psql_user,
        password=psql_password,
        host=psql_host,
        port=psql_port
    )

    insert_statement = """
INSERT INTO journey (
    departure_time,
    return_time,
    departure_station_id,
    departure_station_name,
    return_station_id,
    return_station_name,
    distance,
    duration
)
VALUES (
    %(departure_time)s,
    %(return_time)s,
    %(departure_station_id)s,
    %(departure_station_name)s,
    %(return_station_id)s,
    %(return_station_name)s,
    %(distance)s,
    %(duration)s
)
    """
    with connection.cursor() as cursor:
        execute_batch(cursor, insert_statement, journeys, page_size=5000)
    connection.commit()
    print('done')
    connection.close()

def main():
    journeypath = download_and_filter(journey_sources)
    push_to_sql(journeypath)

if __name__ == "__main__":
    main()
#+end_src

** The backend

The backend is a facade for the database.  Initially the frontend made SQL calls directly, but one of the assignment requirements mandated a backend.

A client may interface with the backend via a HTTP.  HTTP requests are translated into SQL queries and executed on a PostgreSQL database instance.  Query results are sent back to the client that interfaced with the backend.

It is implemented in Python using [[https://flask.palletsprojects.com][flask]] and [[https://flask-restful.readthedocs.io/en/latest/index.html][flask_restful]].

The implementation follows the [[https://en.wikipedia.org/wiki/Multitier_architecture][3 tier]] archiectural pattern:
+ A presentation layer
+ A logic layer
+ A data access layer

The logic layer declares the interfaces and classes that are used to communicate with it.  The presentation and the data access layers implement the interfaces declared by the logic layer.  The API is pretty dumb so the logic layer mostly deals with validating inputs.

In this case there is a single implementation of the presentation layer.  A HTTP server implemented with flask_restful.  The same applies for the data access layer, which is an interface to a PostgreSQL database.

*** Unit tests for backend

There are a few unit tests that you can run via:

#+begin_src sh
cd hcb-backend
python -m venv test-env
./test-env/bin/pip install --upgrade pip
./test-env/bin/pip install --requirement requirements.txt
./test-env/bin/python -m unittest
#+end_src

#+header: :tangle hcb-backend/tests/__init__.py
#+begin_src python
#+end_src

*** requirements.txt

#+header: :tangle hcb-backend/requirements.txt
#+begin_src text
Flask
flask_restful
psycopg2-binary
#+end_src

*** Logic layer

**** Contracts for interfacing layers

These are the objects that are the presentation layer uses to communicate with the [[#logic-layer][logic layer]].  Inputs should be wrapped into the objects defined in the below file and then passed to the [[#logic-layer][logic layer]].  Logic layer performs rules validation and passes the object to the datastore layer, which then constructs a query and queries the datastore.

See the class =HCB= for the flow.

#+header: :tangle hcb-backend/hcb/logic/objects.py
#+begin_src python
from abc import ABC, abstractmethod

class InputObject(ABC):
    """An abstract object representing the inputs of a request.

    An implementation should not constrain the types or values that
    may be stored using its __init__.  Instead it must communicate
    errors using a validate method.

    """
    @abstractmethod
    def validate(self):
        """Validate self.

        Return validation errors as a list.  Empty list means there
        were no errors.  Must not raise validation errors.

        """
        return NotImplemented

    @abstractmethod
    def asdict(self):
        """Convert the object into a dict.

        The object should be recretable using the following:
        InputObjectImpl(**InputObjectImpl.asdict(**args)).

        """
        return NotImplemented

class StationsParams(InputObject):
    """Create an object representing a request for a list of stations.

    - page :: index of the requested page
    - page_size :: number of stations displayed per page
    - search_term :: text filtering option

    """

    def __init__(self, page, page_size, search_term):
        self.page = page
        self.page_size = page_size
        self.search_term = search_term

    def validate(self):
        errors = []
        if not isinstance(self.page, int):
            errors.append('page must be an int')
        if isinstance(self.page, int):
            if not self.page >= 1:
                errors.append('page must be ≥ 1')

        if not isinstance(self.page_size, int):
            errors.append('page size must be an int')

        if isinstance(self.page_size, int):
            if not self.page_size >= 5:
                errors.append('page size must be ≥ 5')
            if not self.page_size <= 50:
                errors.append('page size must be ≤ 50')

        if not len(str(self.search_term)) <= 50:
            errors.append(
                'search term must be shorter or equal to 50 characters'
            )
        return errors

    def asdict(self):
        return {
            'page': self.page,
            'page_size': self.page_size,
            'search_term': self.search_term
        }


class StationInfoParams(InputObject):
    """Create an object representing a request for the details of a station.

    - id :: station identifier
    - months :: month filter, a sequence of month identifiers

    """
    def __init__(self, id, months):
        self.id = id
        self.months = months

    def validate(self):
        errors = []

        if not isinstance(self.id, int):
            errors.append('id must be an int')
        if isinstance(self.id, int) and not self.id >= 0:
            errors.append('id must be ≥ 0')

        if not isinstance(self.months, tuple):
            errors.append('months must be a tuple')

        if isinstance(self.months, tuple):
            length = len(self.months)
            if not length >= 1:
                errors.append("months' length must be [1, 3]")
            if not length <= 3:
                errors.append("months' length must be [1, 3]")
            for el in self.months:
                if not isinstance(el, int):
                    errors.append("months' elements must be of int type")
        return errors

    def asdict(self):
        return {
            'id': self.id,
            'months': self.months
        }


class JourneysParams(InputObject):
    """Create an object representing a request for the list of stations.

    - page :: index of the request page
    - page_size :: number of results on a page
    - search_term :: text filter
    - order_by :: field to order by
    - direction :: modify ordering direction

    """

    columns = ['id', 'departure_station', 'return_station', 'distance', 'duration']
    directions = ['asc', 'desc']

    def __init__(self, page, page_size, search_term, order_by, direction):
        self.page = page
        self.page_size = page_size
        self.search_term = search_term
        self.order_by = order_by
        self.direction = direction

    def validate(self):
        errors = []
        if not isinstance(self.page, int):
            errors.append('page must be an int')


        if isinstance(self.page, int) and not self.page >= 1:
            errors.append('page must be ≥ 1')

        if not isinstance(self.page_size, int):
            errors.append('page size must be an int')

        if isinstance(self.page_size, int):
            if not self.page_size >= 5:
                errors.append('page size must be ≥ 5')
            if not self.page_size <= 50:
                errors.append('page size must be ≤ 50')

        if not len(str(self.search_term)) <= 50:
            errors.append('search term must be shorter or equal to 50 characters')

        if str(self.order_by) not in JourneysParams.columns:
            errors.append(f'order by must be one of {JourneysParams.columns}')

        if str(self.direction) not in JourneysParams.directions:
            errors.append(f'direction must be one of {JourneysParams.directions}')

        return errors

    def asdict(self):
        return {
            'page': self.page,
            'page_size': self.page_size,
            'search_term': self.search_term,
            'order_by': self.order_by,
            'direction': self.direction
        }

class ValidationError(ValueError):
    def __init__(self, message, errors):
        super().__init__(message)
        self.errors = errors


class HCB:
    """Interaction class of the logic layer.

    Presentation layer calls methods on this class directly.  This
    class then validates inputs and calls the provided datastore's
    methods.

    Parameter datastore should be an implementation of the Datastore ABC.

    """

    def __init__(self, datastore):
        self.datastore = datastore

    def journeys(self, params):
        if not isinstance(params, JourneysParams):
            raise TypeError('Expected a JourneysParams as parameter')

        validation_result = params.validate()

        if validation_result != []:
            raise ValidationError(
                'JourneysParams contained bad fields',
                validation_result
            )

        return self.datastore.journeys(params)

    def stations(self, params):
        if not isinstance(params, StationsParams):
            raise TypeError('Expected a StationsParams as parameter')

        validation_errors = params.validate()

        if validation_errors != []:
            raise ValidationError(
                'StationsParams contained bad fields',
                validation_errors
            )
        return self.datastore.stations(params)

    def station_info(self, params):
        if not isinstance(params, StationInfoParams):
            raise TypeError('Expected a StationInfoParams instance as parameter')

        validation_errors = params.validate()

        if len(validation_errors) > 0:
            raise ValidationError(
                'StationInfoParams contained bad fields',
                validation_errors
            )

        return self.datastore.station_info(params)

    def random_station_id(self):
        return self.datastore.random_station_id()
#+end_src

These are the tests for the above.

#+header: :tangle hcb-backend/tests/logic/test_objects.py
#+begin_src python
from unittest import TestCase
from hcb.logic.objects import StationsParams, JourneysParams, StationInfoParams, HCB

class TestJourneysParams(TestCase):

    def test_as_dict_produces_a_dict_of_the_arguments(self):
        args = {
            'page': 1,
            'page_size': 5,
            'search_term': 'hello',
            'order_by': 'col',
            'direction': 'up'
        }

        params = JourneysParams(**args)
        self.assertDictEqual(params.asdict(), args)

    def test_errors_if_page_is_not_int(self):
        params = JourneysParams(None, None, None, None, None)
        self.assertIn('page must be an int', params.validate())

    def test_errors_if_page_lt_1(self):
        params = JourneysParams(0, None, None, None, None)
        self.assertIn('page must be ≥ 1', params.validate())

    def test_page_size_not_int_is_an_error(self):
        params = JourneysParams(None, None, None, None, None)
        self.assertIn('page size must be an int', params.validate())

    def test_page_size_lt_1_is_an_error(self):
        params = JourneysParams(None, 0, None, None, None)
        self.assertIn('page size must be ≥ 5', params.validate())

    def test_page_size_gt_50_is_an_error(self):
        params = JourneysParams(None, 51, None, None, None)
        self.assertIn('page size must be ≤ 50', params.validate())

    def test_search_term_must_be_le_50_chars(self):
        params = JourneysParams(None, None, ' ' * 51, None, None)
        self.assertIn(
            'search term must be shorter or equal to 50 characters',
            params.validate()
        )

    def test_order_by_must_be_one_of_predefined_values(self):
        params = JourneysParams(None, None, None, None, None)
        self.assertIn(
            "order by must be one of ['id', 'departure_station', 'return_station', 'distance', 'duration']",
            params.validate()
        )

    def test_direction_must_be_one_of_predefined_values(self):
        params = JourneysParams(None, None, None, None, None)
        self.assertIn(
            "direction must be one of ['asc', 'desc']",
            params.validate()
        )

    def test_eq_returns_false_if_other_is_not_an_instance_of_JourneysParams(self):
        params = JourneysParams(None, None, None, None, None)
        self.assertNotEqual(params, None)

    def test_eq_false_if_page_does_not_match(self):
        params = JourneysParams(1, None, None, None, None)
        params2 = JourneysParams(None, None, None, None, None)
        self.assertNotEqual(params, params2)

    def test_eq_false_if_page_size_does_not_match(self):
        params = JourneysParams(None, 1, None, None, None)
        params2 = JourneysParams(None, None, None, None, None)
        self.assertNotEqual(params, params2)

    def test_eq_false_if_search_term_does_not_match(self):
        params = JourneysParams(None, None, '', None, None)
        params2 = JourneysParams(None, None, None, None, None)
        self.assertNotEqual(params, params2)

    def test_eq_false_if_order_by_does_not_match(self):
        params = JourneysParams(None, None, None, 'id', None)
        params2 = JourneysParams(None, None, None, None, None)
        self.assertNotEqual(params, params2)

    def test_eq_false_if_direction_does_not_match(self):
        params = JourneysParams(None, None, None, None, 'asc')
        params2 = JourneysParams(None, None, None, None, None)
        self.assertNotEqual(params, params2)


class TestStationInfoParams(TestCase):

    def test_asdict_produces_dict_of_arguments(self):
        params = StationInfoParams(id=1, months=(5))
        self.assertDictEqual(params.asdict(), {
            'id': 1,
            'months': (5)
        })

    def test_errors_if_id_is_not_int(self):
        params = StationInfoParams(None, None)
        self.assertIn('id must be an int', params.validate())

    def test_errors_if_id_lt_0(self):
        params = StationInfoParams(-1, None)
        self.assertIn('id must be ≥ 0', params.validate())

    def test_errors_if_months_not_a_tuple(self):
        params = StationInfoParams(None, None)
        self.assertIn('months must be a tuple', params.validate())

    def test_errros_if_months_longer_than_3(self):
        params = StationInfoParams(None, (1, 2, 3, 4))
        self.assertIn('months\' length must be [1, 3]', params.validate())

    def test_errors_if_months_empty(self):
        params = StationInfoParams(None, ())
        self.assertIn('months\' length must be [1, 3]', params.validate())

    def test_errors_if_months_contains_non_int_values(self):
        params = StationInfoParams(None, ('1',))
        self.assertIn('months\' elements must be of int type', params.validate())

class TestStationsParams(TestCase):

    def test_as_dict_produces_a_dict_of_the_arguments(self):
        params = StationsParams(1, 5, 'hello')

        self.assertDictEqual(
            params.asdict(), {
                'page': 1,
                'page_size': 5,
                'search_term': 'hello'
            }
        )

    def test_page_not_int_is_an_error(self):
        params = StationsParams(None, None, None)
        self.assertIn('page must be an int', params.validate())

    def test_page_lt_1_is_an_error(self):
        params = StationsParams(0, None, None)
        self.assertIn('page must be ≥ 1', params.validate())

    def test_page_size_not_int_is_an_error(self):
        params = StationsParams(None, None, None)
        self.assertIn('page size must be an int', params.validate())

    def test_page_size_lt_1_is_an_error(self):
        params = StationsParams(None, 0, None)
        self.assertIn('page size must be ≥ 5', params.validate())

    def test_page_size_gt_50_is_an_error(self):
        params = StationsParams(None, 51, None)
        self.assertIn('page size must be ≤ 50', params.validate())

    def test_search_term_must_be_le_50_chars(self):
        params = StationsParams(None, None, ' ' * 51)
        self.assertIn(
            'search term must be shorter or equal to 50 characters',
            params.validate()
        )


class TestHCB(TestCase):
    def setUp(self):
        self.datastore = Mock()
        self.hcb = HCB(self.datastore)

    def test_journeys_raises_TypeError_if_parameter_is_not_JourneysParams(self):
        with self.assertRaisesRegex(TypeError, 'JourneysParams'):
            self.hcb.journeys(Mock())

    def test_journeys_raises_ValidationError_if_JourneysParams_signals_errors(self):
        with self.assertRaises(ValidationError):
            self.hcb.journeys(JourneysParams(None, None, None, None, None))

    def test_journeys_calls_datastore_proxying_parameter(self):
        params = JourneysParams(
            page=1,
            page_size=5,
            search_term='',
            order_by='id',
            direction='asc'
        )

        self.hcb.journeys(params)
        self.datastore.journeys.assert_called_with(params)

    def test_journeys_proxies_rval_of_datastore(self):
        rval = self.hcb.journeys(
            JourneysParams(
                page=1,
                page_size=5,
                search_term='',
                order_by='id',
                direction='asc'
            )
        )
        self.assertEqual(rval, self.datastore.journeys())

    def test_stations_raises_TypeError_if_parameter_is_not_StationsParams(self):
        with self.assertRaisesRegex(TypeError, 'StationsParams'):
            self.hcb.stations(None)

    def test_stations_raises_ValidationError_if_params_does_not_validate(self):
        with self.assertRaises(ValidationError):
            self.hcb.stations(StationsParams(None, None, None))

    def test_stations_calls_datastore_and_proxies_params(self):
        params = StationsParams(
            page=1,
            page_size=5,
            search_term=''
        )
        self.hcb.stations(params)
        self.datastore.stations.assert_called_with(params)

    def test_stations_proxies_rval_of_datastore(self):
        rval = self.hcb.stations(
            StationsParams(
                page=1,
                page_size=5,
                search_term=''
            )
        )
        self.assertEqual(rval, self.datastore.stations())

    def test_random_station_id_proxies_rval_of_store(self):
        rval = self.hcb.random_station_id()
        self.assertEqual(rval, self.datastore.random_station_id())

    def test_station_info_raises_TypeError_if_parameter_not_StationInfoParams(self):
        with self.assertRaisesRegex(TypeError, 'StationInfoParams'):
            self.hcb.station_info(None)

    def test_station_info_raises_ValidationError_if_params_does_not_validate(self):
        with self.assertRaises(ValidationError):
            self.hcb.station_info(StationInfoParams(None, None))

    def test_station_info_calls_datastore_and_proxies_params(self):
        params = StationInfoParams(
            id=1,
            months=(5,)
        )
        self.hcb.station_info(params)
        self.datastore.station_info.assert_called_with(params)

    def test_station_info_proxies_rval_of_datastore(self):
        rval = self.hcb.station_info(
            StationInfoParams(
                id=1,
                months=(5,)
            )
        )
        self.assertEqual(rval, self.datastore.station_info())
#+end_src

These are the objects the datastore layer uses to communicate with the [[#logic-layer][logic layer]].

+ Output objects from whatever datastore used should be wrapped into objects defined below
+ Input objects (=*Params=) must be used to filter the database
+ The datastore class must implement the contract defined in the =Datastore= abc.

#+begin_src python :tangle hcb-backend/hcb/logic/objects.py
from abc import ABC, abstractmethod


class OutputObject(ABC):
    """An abstract base class representing a single datastore object."""

    @abstractmethod
    def asdict(self):
        """Convert the object into a dict.

        The object should be recretable using the following:
        OutputObjectImpl(**OutputObjectImpl.asdict(**args)).

        """
        return NotImplemented


class Journey(OutputObject):
    def __init__(
            self,
            departure_station_id,
            departure_station_name,
            return_station_id,
            return_station_name,
            distance,
            duration
    ):
        self.departure_station_id = departure_station_id
        self.departure_station_name = departure_station_name
        self.return_station_id = return_station_id
        self.return_station_name = return_station_name
        self.distance = distance
        self.duration = duration

    def asdict(self):
        return {
            'departure_station_id': self.departure_station_id,
            'departure_station_name': self.departure_station_name,
            'return_station_id': self.return_station_id,
            'return_station_name': self.return_station_name,
            'distance': self.distance,
            'duration': self.duration
        }

class Station(OutputObject):
    def __init__(self, id, name, address):
        self.id = id
        self.name = name
        self.address = address

    def asdict(self):
        return {
            'id': self.id,
            'name': self.name,
            'address': self.address
        }


class RelatedStation(OutputObject):
    def __init__(self, id, name, journeys):
        self.id = id
        self.name = name
        self.journeys = journeys

    def asdict(self):
        return {
            'id': self.id,
            'name': self.name,
            'journeys': self.journeys
        }


class StationInfo(OutputObject):
    def __init__(
            self,
            name,
            address,
            x,
            y,
            journeys_started_here,
            journeys_ended_here,
            average_distance_started_here,
            average_distance_ended_here,
            top_destinations,
            top_origins
    ):
        self.name = name
        self.address = address
        self.x = x
        self.y = y
        self.journeys_started_here = journeys_started_here
        self.journeys_ended_here = journeys_ended_here
        self.average_distance_started_here = average_distance_started_here
        self.average_distance_ended_here = average_distance_ended_here
        self.top_destinations = top_destinations
        self.top_origins = top_origins

    def asdict(self):
        return {
            'name': self.name,
            'address': self.address,
            'x': self.x,
            'y': self.y,
            'journeys_started_here': self.journeys_started_here,
            'journeys_ended_here': self.journeys_ended_here,
            'average_distance_started_here': self.average_distance_started_here,
            'average_distance_ended_here': self.average_distance_ended_here,
            'top_destinations': [station.asdict() for station in self.top_destinations],
            'top_origins': [station.asdict() for station in self.top_origins]
        }


class Datastore(ABC):
    """An abstract base class for datastores to implement."""

    @abstractmethod
    def journeys(self, params):
        """Fetch stored journeys.

        params is a JourneysParams object.

        It must return a sequence of Journey objects.

        """
        return NotImplemented

    @abstractmethod
    def stations(self, params):
        """Fetch stored stations.

        params is a StationsParams object.

        It must return a sequence of Station objects.

        """
        return NotImplemented

    @abstractmethod
    def station_info(self, params):
        """Fetch info about a station.

        params is a StationInfoParams object.

        It must return a StationInfo object.

        """
        return NotImplemented

    @abstractmethod
    def random_station_id(self):
        """Fetch a random station id.

        It must return an int.

        """
        return NotImplemented
#+end_src

Here are tests for the above.

#+header: :tangle hcb-backend/tests/logic/__init__.py
#+begin_src python

#+end_src

#+header: :tangle hcb-backend/tests/logic/test_objects.py
#+begin_src python
from unittest import TestCase
from unittest.mock import Mock

from hcb.logic.objects import Journey, Station, RelatedStation, StationInfo, ValidationError

class TestJourney(TestCase):
    def test_asdict_produces_a_dict_of_the_params(self):
        journey = Journey(
            departure_station_id=1,
            departure_station_name='kannel',
            return_station_id=2,
            return_station_name='mäki',
            distance=3,
            duration=4
        )

        self.assertDictEqual(journey.asdict(), {
            'departure_station_id': 1,
            'departure_station_name': 'kannel',
            'return_station_id': 2,
            'return_station_name': 'mäki',
            'distance': 3,
            'duration': 4
        })

class TestStation(TestCase):
    def test_asdict_produces_a_dict_of_the_params(self):
        station = Station(
            id=1,
            name='kannel',
            address='kaari'
        )

        self.assertDictEqual(station.asdict(), {
            'id': 1,
            'name': 'kannel',
            'address': 'kaari'
        })

class TestRelatedStation(TestCase):
    def test_asdict_produces_a_dict_of_the_params(self):
        station = RelatedStation(
            id=1,
            name='kannel',
            journeys=2
        )

        self.assertDictEqual(station.asdict(), {
            'id': 1,
            'name': 'kannel',
            'journeys': 2
        })

class TestStationInfo(TestCase):
    def test_asdict_produces_a_dict_of_the_params(self):
        stationinfo = StationInfo(
            name='a',
            address='b',
            x=1.0,
            y=2.0,
            journeys_started_here=1,
            journeys_ended_here=2,
            average_distance_started_here=3,
            average_distance_ended_here=4,
            top_destinations=[],
            top_origins=[]
        )

        self.assertDictEqual(stationinfo.asdict(), {
            'name': 'a',
            'address': 'b',
            'x': 1.0,
            'y': 2.0,
            'journeys_started_here': 1,
            'journeys_ended_here': 2,
            'average_distance_started_here': 3,
            'average_distance_ended_here': 4,
            'top_destinations': [],
            'top_origins': []
        })
#+end_src

*** Presentation layer

#+header: :tangle hcb-backend/hcb/presentation/http.py
#+begin_src python
from flask import request, Flask
from flask_restful import Resource, Api, fields, marshal_with
from hcb.logic.objects import JourneysParams, StationsParams, StationInfoParams

class JourneyList(Resource):
    def __init__(self, hcb):
        self.hcb = hcb

    def get(self):
        page = request.args.get('page', '1')
        page = int(page) if page.isdecimal() else page
        page_size = request.args.get('page_size', '10')
        page_size = int(page_size) if page_size.isdecimal() else page_size
        search_term = request.args.get('search', '')
        order_by = request.args.get('order_by', 'id')
        direction = request.args.get('direction', 'asc')

        params = JourneysParams(
            page, page_size, search_term, order_by, direction
        )

        validation_errors = params.validate()
        if validation_errors:
            return validation_errors, 400

        journeys = self.hcb.journeys(params)
        return [journey.asdict() for journey in journeys]

class StationList(Resource):

    def __init__(self, hcb):
        self.hcb = hcb


    def get(self):
        page = request.args.get('page', '1')
        page = int(page) if page.isdecimal() else page
        page_size = request.args.get('page_size', '10')
        page_size = int(page_size) if page_size.isdecimal() else page_size
        search_term = request.args.get('search', '')

        params = StationsParams(page, page_size, search_term)

        validation_errors = params.validate()
        if validation_errors:
            return validation_errors, 400
        stations = self.hcb.stations(params)
        return [station.asdict() for station in stations]


class StationInfo(Resource):

    def __init__(self, hcb):
        self.hcb = hcb

    def get(self, id):
        months = request.args.getlist('month')

        months = tuple(map(int, months)) if len(months) > 0 else (5, 6, 7)

        params = StationInfoParams(id, months)

        validation_errors = params.validate()

        if validation_errors:
            return validation_errors, 400
        station_info = self.hcb.station_info(params)
        return station_info.asdict()

class RandomStation(Resource):

    def __init__(self, hcb):
        self.hcb = hcb

    def get(self):
        return self.hcb.random_station_id()


def make_app(name, hcb):
    app = Flask(name)
    api = Api(app)
    api.add_resource(
        JourneyList,
        '/journeys',
        resource_class_kwargs={
            'hcb': hcb
        }
    )

    api.add_resource(
        StationList,
        '/stations',
        resource_class_kwargs={
            'hcb': hcb
        }
    )

    api.add_resource(
        StationInfo,
        '/stations/<int:id>',
        resource_class_kwargs={
            'hcb': hcb
        }
    )

    api.add_resource(
        RandomStation,
        '/stations/random',
        resource_class_kwargs={
            'hcb': hcb
        }
    )

    return app
#+end_src

#+header: :tangle hcb-backend/tests/presentation/__init__.py
#+begin_src python
#+end_src

#+header: :tangle hcb-backend/tests/presentation/test_http.py
#+begin_src python
from unittest import TestCase
from unittest.mock import Mock

from hcb.presentation import http
from hcb.logic import objects

class TestJourneyList(TestCase):
    def setUp(self):
        self.hcb = Mock()
        self.app = http.make_app('test', self.hcb)
        self.client = self.app.test_client()

    def test_sets_default_values_for_parameters_if_not_provided(self):
        self.hcb.journeys.return_value = []
        expected_params = objects.JourneysParams(page=1, page_size=10, search_term='', order_by='id', direction='asc')
        self.client.get('/journeys')
        self.hcb.journeys.call_args[0] == expected_params

    def test_bad_parameter_causes_400(self):
        response = self.client.get(
            '/journeys',
            query_string={
                'page': 0
            })
        self.assertEqual(response.status_code, 400)

class TestStationList(TestCase):
    def setUp(self):
        self.hcb = Mock()
        self.app = http.make_app('test', self.hcb)
        self.client = self.app.test_client()

    def test_sets_default_values_for_parameters_if_not_provided(self):
        self.hcb.stations.return_value = []
        expected_params = objects.StationsParams(page=1, page_size=10, search_term='')
        self.client.get('/stations')
        self.hcb.stations.call_args[0] == expected_params

    def test_bad_parameter_causes_400(self):
        response = self.client.get(
            '/stations',
            query_string={
                'page': 0
            })
        self.assertEqual(response.status_code, 400)

class TestStationInfo(TestCase):
    def setUp(self):
        self.hcb = Mock()
        self.app = http.make_app('test', self.hcb)
        self.client = self.app.test_client()

class TestRandomStation(TestCase):

    def setUp(self):
        self.hcb = Mock()
        self.app = http.make_app('test', self.hcb)
        self.client = self.app.test_client()
#+end_src


*** Datastore layer

Here's an implementation of the =Datastore= in PostgreSQL.

#+header: :tangle hcb-backend/hcb/datastore/sql.py
#+begin_src python
from psycopg2.pool import ThreadedConnectionPool
from psycopg2.extensions import AsIs

import functools
from abc import ABC, abstractmethod
from collections import namedtuple

from hcb.logic.objects import Datastore, Journey, Station, StationInfo, RelatedStation


def with_database(func):
    """Wrap PSQLStore fetch function with a connection."""

    @functools.wraps(func)
    def wrap_with_connection(store, *args):
        connection = store.connections.getconn()
        try:
            response = func(store, connection, *args)
        finally:
            store.connections.putconn(connection)
        return response
    return wrap_with_connection

def with_cursor(func):
    """Wrap a PSQLStore fetch function with a cursor."""

    @functools.wraps(func)
    def wrap_with_cursor(store, connection, *args):
        with connection.cursor() as cursor:
            response = func(store, cursor, *args)
        return response
    return wrap_with_cursor


class SQLInputObject(ABC):

    @abstractmethod
    def sql_params(self):
        """Convert InputObject into a prepared statement parameters dict."""
        raise NotImplemented

class JourneysSQLParams(SQLInputObject):
    """Prepared statement parameters object for PSQLStore.journeys."""

    order_by_mapping = {
        'departure_station': 'journey.departure_station_name',
        'return_station': 'journey.return_station_name',
        'distance': 'journey.distance',
        'duration': 'journey.duration',
        'id': 'journey.id',
        None: 'journey.id'
    }

    direction_mapping = {
        'asc': 'ASC',
        'desc': 'DESC',
        None: 'ASC'
    }

    def __init__(self, params):
        self.params = params

    @property
    def offset(self):
        return (self.params.page - 1) * self.params.page_size

    @property
    def page_size(self):
        return self.params.page_size

    @property
    def search_term(self):
        return f'%{self.params.search_term}%'

    @property
    def order_by(self):
        return AsIs(JourneysSQLParams.order_by_mapping[self.params.order_by])

    @property
    def direction(self):
        return AsIs(JourneysSQLParams.direction_mapping[self.params.direction])

    def sql_params(self):
        return {
            'page_size': self.page_size,
            'offset': self.offset,
            'search_term': self.search_term,
            'order_by': self.order_by,
            'direction': self.direction
        }

class StationsSQLParams(SQLInputObject):
    """Prepared statement parameters object for PSQLStore.stations."""

    def __init__(self, params):
        self.params = params

    @property
    def offset(self):
        return (self.params.page - 1) * self.params.page_size

    @property
    def page_size(self):
        return self.params.page_size

    @property
    def search_term(self):
        return f'%{self.params.search_term}%'

    def sql_params(self):
        return {
            'offset': self.offset,
            'page_size': self.page_size,
            'search_term': self.search_term
        }

class StationInfoSQLParams(SQLInputObject):
    """Prepared statement parameters object for PSQLStore.station_info and children."""

    def __init__(self, params):
        self.params = params

    @property
    def id(self):
        return self.params.id

    @property
    def months(self):
        return self.params.months

    def sql_params(self):
        return {
            'id': self.id,
            'months': self.months
        }

class PSQLStore(Datastore):
    def __init__(self, host, port, user, password, database):
        self.min_connections = 1
        self.max_connections = 3
        self.host = host
        self.port = port
        self.user = user
        self.password = password
        self.database = database

        self.connections = ThreadedConnectionPool(
            minconn=self.min_connections,
            maxconn=self.max_connections,
            host=self.host,
            port=self.port,
            user=self.user,
            password=self.password,
            database=self.database
        )

    @with_database
    @with_cursor
    def journeys(self, cursor, params):
        sql = """
SELECT
        departure_station.fid as departure_station_id,
        departure_station_name,
        return_station.fid as return_station_id,
        return_station_name,
        distance * 0.001,
        duration / 60
FROM journey
JOIN station AS departure_station
ON departure_station_id = departure_station.id
JOIN station AS return_station
ON return_station_id = return_station.id
WHERE departure_station_name ILIKE %(search_term)s ESCAPE ''
      OR return_station_name ILIKE %(search_term)s ESCAPE ''
ORDER BY %(order_by)s %(direction)s, journey.id ASC
LIMIT %(page_size)s
OFFSET %(offset)s
        """
        params = JourneysSQLParams(params)
        cursor.execute(sql, params.sql_params())
        values = cursor.fetchall()
        return [Journey(*val) for val in values]

    ####################################################
    # Here are methods used by PSQLStore.station_info  #
    ####################################################

    @with_database
    @with_cursor
    def station_info(self, cursor, params):
        params = StationInfoSQLParams(params)

        station = self._station(cursor, params)
        journeys = self._journeys_from_and_to_station(cursor, params)
        distances = self._average_distances_from_and_to_station(cursor, params)
        destinations = [RelatedStation(*station) for station in
            self._top_destination_stations(cursor, params)
        ]
        origins = [
            RelatedStation(*station) for station in
            self._top_origin_stations(cursor, params)
        ]


        info = StationInfo(
            name=station.name,
            address=station.address,
            x=station.x,
            y=station.y,
            journeys_started_here=journeys.departures,
            journeys_ended_here=journeys.returns,
            average_distance_started_here=distances.departure_distance,
            average_distance_ended_here=distances.return_distance,
            top_destinations=destinations,
            top_origins=origins
        )
        return info

    Station = namedtuple('Station', 'name address x y')

    def _station(self, cursor, params):
        """Get a station referenced in the params argument.

        params is of type StationInfoSQLParams.

        """

        sql = """
SELECT finnish_name as name, finnish_address as address, x, y
FROM station
WHERE fid = %(id)s
        """
        cursor.execute(sql, params.sql_params())
        return PSQLStore.Station(*cursor.fetchone())

    StationJourneys = namedtuple('StationJourneys', 'returns departures')

    def _journeys_from_and_to_station(self, cursor, params):
        sql = """
WITH station AS (
    SELECT id
    FROM station
    WHERE fid = %(id)s
),
statistics AS (
    SELECT (
        SELECT id FROM station
    ), (
        SELECT COUNT(*)
        FROM journey
        JOIN station
        ON station.id = departure_station_id
        WHERE EXTRACT(MONTH FROM departure_time) IN %(months)s
    ) as departures,
    ( SELECT COUNT(*)
        FROM journey
        JOIN station
        ON station.id = return_station_id
        WHERE EXTRACT(MONTH FROM departure_time) IN %(months)s
    ) as returns
)
SELECT returns, departures
FROM station
JOIN statistics
ON station.id = statistics.id
        """
        cursor.execute(sql, params.sql_params())
        return PSQLStore.StationJourneys(*cursor.fetchone())

    AverageDistances = namedtuple('AverageDistances', 'return_distance departure_distance')

    def _average_distances_from_and_to_station(self, cursor, params):
        sql = """
WITH station AS (
    SELECT id
    FROM station
    WHERE fid = %(id)s
),
statistics AS (
    SELECT (
        SELECT id FROM station
    ), (
        SELECT AVG(distance) as average_departure_distance
        FROM journey
        JOIN station
        ON station.id = departure_station_id
        WHERE EXTRACT(MONTH FROM departure_time) IN %(months)s
    ) as departure_distance,
    (
        SELECT AVG(distance) as average_return_distance
        FROM journey
        JOIN station
        ON station.id = return_station_id
        WHERE EXTRACT(MONTH FROM departure_time) IN %(months)s
    ) as return_distance
)
SELECT return_distance, departure_distance
FROM station
JOIN statistics
ON station.id = statistics.id
"""
        cursor.execute(sql, params.sql_params())
        return PSQLStore.AverageDistances(*cursor.fetchone())

    TargetStation = namedtuple('TargetStation', 'id name journeys')

    def _top_destination_stations(self, cursor, params):
        sql = """
WITH our_station AS (
     SELECT id
     FROM station
     WHERE fid = %(id)s
),
top_destinations AS (
     SELECT return_station_id, COUNT(*)
     FROM journey
     JOIN our_station
     ON journey.departure_station_id = our_station.id
     WHERE EXTRACT(MONTH FROM departure_time) IN %(months)s
     GROUP BY return_station_id
     ORDER BY count DESC
     LIMIT 5
)
SELECT station.fid as id, station.finnish_name as name, count as journeys
FROM top_destinations
JOIN station
ON station.id = top_destinations.return_station_id
ORDER BY count DESC
"""
        cursor.execute(sql, params.sql_params())
        return [
            PSQLStore.TargetStation(*station) for station in
                cursor.fetchall()
        ]

    def _top_origin_stations(self, cursor, params):
        sql = """
WITH our_station AS (
     SELECT id
     FROM station
     WHERE fid = %(id)s
),
top_origins AS (
     SELECT departure_station_id, COUNT(*)
     FROM journey
     JOIN our_station
     ON journey.return_station_id = our_station.id
     WHERE EXTRACT(MONTH FROM departure_time) IN %(months)s
     GROUP BY departure_station_id
     ORDER BY count DESC
     LIMIT 5
)
SELECT station.fid as id, station.finnish_name as name, count as journeys
FROM top_origins
JOIN station
ON station.id = top_origins.departure_station_id
ORDER BY count DESC
        """
        cursor.execute(sql, params.sql_params())
        return [
            PSQLStore.TargetStation(*station) for station in
            cursor.fetchall()
        ]

    @with_database
    @with_cursor
    def stations(self, cursor, params):
        sql = """
SELECT fid, finnish_name, finnish_address
FROM station
WHERE finnish_name ILIKE %(search_term)s ESCAPE ''
    OR finnish_address ILIKE %(search_term)s ESCAPE ''
ORDER BY finnish_name, finnish_address, fid ASC
LIMIT %(page_size)s
OFFSET %(offset)s
        """
        params = StationsSQLParams(params)
        cursor.execute(sql, params.sql_params())
        values = cursor.fetchall()
        return [Station(*val) for val in values]

    @with_database
    @with_cursor
    def random_station_id(self, cursor):
        sql = """
SELECT fid
FROM station
ORDER BY RANDOM()
LIMIT 1
        """

        cursor.execute(sql)
        result = cursor.fetchone()
        return result[0]
#+end_src

#+header: :tangle hcb-backend/tests/datastore/__init__.py
#+begin_src python
#+end_src

Here are the tests for the PSQL datastore.

#+begin_src python :tangle hcb-backend/tests/datastore/test_sql.py
from unittest import TestCase
from unittest.mock import Mock, MagicMock, patch
from psycopg2.extensions import AsIs

from hcb.logic.objects import (
    JourneysParams,
    Journey,
    Station,
    StationsParams
)
from hcb.datastore.sql import with_database, with_cursor, PSQLStore, JourneysSQLParams, StationsSQLParams


class TestWithDatabase(TestCase):

    def test_requests_database_connection(self):
        store = Mock()
        wrapped_fn = Mock()
        with_database(wrapped_fn)(store)
        store.connections.getconn.assert_called()

    def test_releases_database_connection(self):
       store = Mock()
       connection = store.connections.getconn()
       wrapped_fn = Mock()
       with_database(wrapped_fn)(store)
       store.connections.putconn.assert_called_with(connection)

    def test_releases_database_connection_when_wrapped_fn_raises(self):
       store = Mock()
       connection = store.connections.getconn()
       wrapped_fn = Mock(side_effect=Exception('Mocked exception'))
       try:
           with_database(wrapped_fn)(store)
       except:
           pass
       store.connections.putconn.assert_called_with(connection)

    def test_calls_wrapped_fn_passing_in_store_and_connection_and_args(self):
        store = Mock()
        wrapped_fn = Mock()
        connection = store.connections.getconn()
        a, b = Mock(), Mock()
        with_database(wrapped_fn)(store, a, b)
        wrapped_fn.assert_called_with(store, connection, a, b)

    def test_returns_rvalue_of_wrapped_function(self):
       store = Mock()
       expected_rvalue = Mock()
       wrapped_fn = Mock(return_value=expected_rvalue)
       rvalue = with_database(wrapped_fn)(store)
       self.assertEqual(expected_rvalue, rvalue)

class TestWithCursor(TestCase):
    def test_creates_a_cursor_context_manager(self):
        connection = MagicMock()
        wrapped_fn = Mock()
        with_cursor(wrapped_fn)(None, connection)
        connection.cursor.assert_called()

    def test_enters_cursor_context(self):
        connection = MagicMock()
        wrapped_fn = Mock()
        with_cursor(wrapped_fn)(None, connection)
        connection.cursor().__enter__.assert_called()

    def test_exits_cursor_context(self):
        connection = MagicMock()
        wrapped_fn = Mock()
        with_cursor(wrapped_fn)(None, connection)
        connection.cursor().__exit__.assert_called()

    def test_calls_wrapped_fn_passing_in_store_and_cursor_and_args(self):
         connection = MagicMock()
         cursor = connection.cursor().__enter__()
         store = Mock()
         a, b = Mock(), Mock()
         wrapped_fn = Mock()
         with_cursor(wrapped_fn)(store, connection, a, b)
         wrapped_fn.assert_called_with(store, cursor, a, b)


class TestJourneysSQLParams(TestCase):
    def test_calculates_expected_offsets(self):
        params = JourneysParams(page=2, page_size=5, search_term=None, order_by=None, direction=None)
        expected_offset = 5
        sqlparams = JourneysSQLParams(params)
        self.assertEqual(sqlparams.offset, expected_offset)

    def test_wraps_search_term_in_percent_sign(self):
        params = JourneysParams(page=None, page_size=None, search_term='kannel', order_by=None, direction=None)
        expected_search_term = '%kannel%'
        sqlparams = JourneysSQLParams(params)
        self.assertEqual(sqlparams.search_term, expected_search_term)

    def test_wraps_order_by_in_AsIs(self):
        params = JourneysParams(page=None, page_size=None, search_term=None, order_by='departure_station', direction=None)
        sqlparams = JourneysSQLParams(params)
        self.assertIsInstance(sqlparams.order_by, AsIs)

    def test_order_by_does_not_accept_garbage(self):
        params = JourneysParams(
            page=None,
            page_size=None,
            search_term=None,
            order_by='garbage',
            direction=None
        )

        sqlparams = JourneysSQLParams(params)
        with self.assertRaises(Exception):
            sqlparams.order_by

    def test_wraps_direction_in_AsIs(self):
        params = JourneysParams(page=None, page_size=None, search_term=None, order_by=None, direction='asc')
        sqlparams = JourneysSQLParams(params)
        self.assertIsInstance(sqlparams.direction, AsIs)

    def test_direction_does_not_accept_garbage(self):
        params = JourneysParams(
            page=None,
            page_size=None,
            search_term=None,
            order_by=None,
            direction='garbage'
        )
        sqlparams = JourneysSQLParams(params)
        with self.assertRaises(Exception):
            sqlparams.direction

    def test_sql_params_produces_expected_dict(self):
        params = JourneysParams(page=2, page_size=5, search_term='kannel', order_by='id', direction='asc')
        sqlparams = JourneysSQLParams(params).sql_params()
        sqlparams['order_by'] = str(sqlparams['order_by'])
        sqlparams['direction'] = str(sqlparams['direction'])


        self.assertDictEqual(
            sqlparams, {
                'offset': 5,
                'page_size': 5,
                'search_term': '%kannel%',
                'order_by': 'journey.id',
                'direction': 'ASC'
            })

class TestStationsSQLParams(TestCase):
    def test_calculates_expected_offsets(self):
        params = StationsParams(page=2, page_size=5, search_term=None)
        expected_offset = 5
        sqlparams = StationsSQLParams(params)
        self.assertEqual(sqlparams.offset, expected_offset)

    def test_wraps_search_term_in_percent_sign(self):
        params = StationsParams(page=None, page_size=None, search_term='kannel')
        expected_search_term = '%kannel%'
        sqlparams = StationsSQLParams(params)
        self.assertEqual(sqlparams.search_term, expected_search_term)

    def test_sql_params_produces_expected_dict(self):
        params = StationsParams(page=2, page_size=5, search_term='kannel')
        sqlparams = StationsSQLParams(params).sql_params()

        self.assertDictEqual(
            sqlparams, {
                'offset': 5,
                'page_size': 5,
                'search_term': '%kannel%',
            })


class TestPSQLStoreInit(TestCase):

    @patch('hcb.datastore.sql.ThreadedConnectionPool')
    def test_constructs_a_connection_pool(self, connectionpool):
        p = PSQLStore('localhost', '5432', 'postgres', 'postgres', 'postgres')
        connectionpool.assert_called()


# NB subclasses
class TestPSQLStore(TestCase):
    def setUp(self):
        self.connectionpool = patch('hcb.datastore.sql.ThreadedConnectionPool')
        self.connectionpool.start()
        self.store = PSQLStore('host', 'port', 'user', 'password', 'db')
        self.connection = self.store.connections.getconn()
        self.cursor = self.connection.cursor().__enter__()

    def tearDown(self):
        self.connectionpool.stop()


class TestPSQLStoreJourneys(TestPSQLStore):

    def setUp(self):
        super().setUp()
        self.params = JourneysParams(
            page=1,
            page_size=5,
            search_term='kannel',
            order_by='id',
            direction='asc'
        )

    def test_calls_execute_on_cursor(self):
        self.store.journeys(self.params)
        self.cursor.execute.assert_called()

    def test_calls_fetchall_on_cursor(self):
        self.store.journeys(self.params)
        self.cursor.fetchall.assert_called()

    def test_results_of_fetchall_converted_into_Journey_objects(self):
        self.cursor.fetchall.return_value = [(None, None, None, None, None, None)]
        rvalue = self.store.journeys(self.params)
        self.assertIsInstance(rvalue[0], Journey)

class TestPSQLStoreStations(TestPSQLStore):

    def setUp(self):
        super().setUp()
        self.params = StationsParams(
            page=1,
            page_size=5,
            search_term='kannel'
        )

    def test_calls_execute_on_cursor(self):
        self.store.stations(self.params)
        self.cursor.execute.assert_called()

    def test_calls_fetchall_on_cursor(self):
        self.store.stations(self.params)
        self.cursor.fetchall.assert_called()

    def test_results_of_fetchall_converted_into_Station_objects(self):
        self.cursor.fetchall.return_value = [(None, None, None)]
        rvalue = self.store.stations(self.params)
        self.assertIsInstance(rvalue[0], Station)

class TestPSQLStoreRandomStation(TestPSQLStore):

    def test_calls_execute_on_cursor(self):
        self.store.random_station_id()
        self.cursor.execute.assert_called()

    def test_calls_fetchone_on_cursor(self):
        self.store.random_station_id()
        self.cursor.fetchone.assert_called()

    def test_returns_first_value_in_tuple_returned_by_fetchone(self):
        self.cursor.fetchone.return_value = (0,)
        rvalue = self.store.random_station_id()
        self.assertEqual(rvalue, 0)


class TestPSQLStoreStationInfo(TestPSQLStore):
    pass
#+end_src

*** main.py

#+header: :tangle hcb-backend/main.py
#+begin_src python
from hcb.presentation import http
from hcb.logic.objects import HCB
from hcb.datastore.sql import PSQLStore
import os

db_name = os.environ['PSQL_DB']
db_user = os.environ['PSQL_USER']
db_pass = os.environ['PSQL_PASS']
db_host = os.environ['PSQL_HOST']
db_port = os.environ['PSQL_PORT']

app = http.make_app(
    __name__,
    HCB(
        PSQLStore(db_host, db_port, db_user, db_pass, db_name)
    )
)

if __name__ == "__main__":
    host = os.environ['HCBB_HOST']
    port = os.environ['HCBB_PORT']
    app.run(host=host, port=port, debug=True)
#+end_src

** The frontend

The frontend offers the following views:
+ A home page
+ A journey list
+ A station list
+ A more specific listing of a station.

It is implemented in [[https://www.python.org][Python]] using the [[https://flask.palletsprojects.com][Flask web framework]].  The code is a mess because I didn't have the time to focus on this part of the assignment.

*** Tests for frontend

[[https://robotframework-browser.org][Robot Framework Browser]] is used for testing the frontend.  For running the the tests, you must have a local install of [[https://www.python.org/downloads/][Python]], [[https://nodejs.org/en/download][NodeJS]] and npm.  You also need to have a working instance of the app running in a lcation that is accessible to your machine.  By default the location is set to [[https://hcb.rkll.net]].

To run the tests:

1. Move to directory =hcb-frontend=.
2. Create a virtual environment
3. Install dependencies declared in =robot-requirements.txt=.
4. Install [[https://robotframework-browser.org][Robot Framework Browser's]] browser bundle
5. Execute the =robot= script pointed at the =tests= directory.

#+begin_src sh
cd hcb-frontend
python -m venv test-env
./test-env/bin/pip install --upgrade pip
./test-env/bin/pip install --requirement robot-requirements.txt
./test-env/bin/rfbrowser init
./test-env/bin/robot tests
#+end_src

The tests shouldn't take too long to run.  Success/failure will be logged to stdout, and some reports will be generated in =PWD=.

**** resource.robot

Here's a resource file for the tests.  If you set up the app locally, you may want to update the =SERVER= variable to a local instance, which by default would be [[https://localhost:5434]].

#+header: :tangle hcb-frontend/tests/resource.robot
#+begin_src robot
,*** Settings ***
Library   Browser

,*** Variables ***
${SERVER}        https://hcb.rkll.net

,*** Keywords ***
Title contains Helsinki city bikes
    Get Title  *=  Helsinki city bikes

Navbar exists
    Get Element  nav
    Get Text  .navbar-brand  *=  Helsinki City Bikes
    Get Attribute  .navbar-brand  href  ==  /
    Get Text  id=navbar-journeys-link  ==  Journeys
    Get Attribute  id=navbar-journeys-link  href  ==  /journeys
    Get Text  id=navbar-stations-link  ==  Stations
    Get Attribute  id=navbar-stations-link  href  ==  /stations
#+end_src

**** robot-requirements.txt

#+header: :tangle hcb-frontend/robot-requirements.txt
#+begin_src text
robotframework-browser
#+end_src

**** homepage.robot

These are the tests for the homepage.

#+header: :tangle hcb-frontend/tests/homepage.robot
#+begin_src robot
,*** Settings ***
Documentation  Tests for the app's homepage.
Test Setup     New Page  ${HOMEPAGE_URL}
Resource       resource.robot

,*** Variables ***
${HOMEPAGE_URL}  ${SERVER}/

,*** Test Cases ***
Title contains Home
    Get Title  *=  Home

Title contains Helsinki city bikes
    Title contains Helsinki city bikes

Contains random station button
    Get Text  id=random-station-button  *=  random station

Random button links to /random-station
    Get Attribute  id=random-station-button  href  ==  /random-station

Contains navbar
    Navbar exists
#+end_src

**** journeys.robot

These test the path =/journeys=.

#+header: :tangle hcb-frontend/tests/journeys.robot
#+begin_src robot
,*** Settings ***
Documentation  Tests for the app's journeys page
Test Setup     New Page  ${JOURNEYS_URL}
Resource       resource.robot

,*** Variables ***
${JOURNEYS_URL}  ${SERVER}/journeys

,*** Keywords ***
Clicking ${column_id} orders by ${query}
    Click  id=${column_id}
    Get URL  *=  ${query}

Clicking ${column_id} sorts in ascending order
    Click  id=${column_id}
    GET URL  *=  direction=ascending

Clicking ${column_id} twice sorts in descending order
    Click  id=${column_id}
    Click  id=${column_id}
    GET URL  *=  direction=descending

,*** Test Cases ***
Title contains Journeys
    Get Title  *=  Journeys

Title contains Helsinki city bikes
    Title contains Helsinki city bikes

Contains navbar
    Navbar exists

Contains search form
    Get Element  form
    Get Element  form input
    Get Element  form button

Search contains placeholder text
    Get Attribute  form input  placeholder  ==  Search term

Searching adds query parameter search to url
    Type Text  form input  hello
    Click  form button
    Get Url  *=  search=hello

Navigating to next page updates page url
    Click  id=next-page
    Get URL  *=  page=2

Navigating to previous page updates page url
    Click  id=next-page
    Click  id=previous-page
    Get URL  *=  page=1

Clicking Departure Station column header orders by Departure Station
    Clicking departure-station orders by order_by=departure_station

Clicking Departure Station column header sorts in ascending order
    Clicking departure-station sorts in ascending order

Clicking Departure Station column header twice sorts in descending order
    Clicking departure-station twice sorts in descending order

Clicking Return Station column header orders by Return Station
    Clicking return-station orders by order_by=return_station

Clicking Return Station column header sorts in ascending order
    Clicking return-station sorts in ascending order

Clicking Return Station column header twice sorts in descending order
    Clicking return-station twice sorts in descending order

Clicking Distance column header orders by Distance
    Clicking distance orders by order_by=distance

Clicking Distance column header sorts in ascending order
    Clicking distance sorts in ascending order

Clicking Distance column header twice sorts in descending order
    Clicking distance twice sorts in descending order

Clicking Duration column header orders by Duration
    Clicking duration orders by order_by=duration

Clicking Duration column header sorts in ascending order
    Clicking duration sorts in ascending order

Clicking Duration column header twice sorts in descending order
    Clicking duration twice sorts in descending order
#+end_src

**** stations.robot

These test the =/stations= path.

#+header: :tangle hcb-frontend/tests/stations.robot
#+begin_src robot
,*** Settings ***
Documentation  Tests for the app's stations page
Test Setup     New Page  ${STATIONS_URL}
Resource       resource.robot

,*** Variables ***
${STATIONS_URL}  ${SERVER}/stations

,*** Test Cases ***
Title cointains Stations
   Get Title  *=  Stations

Title contains Helsinki city bikes
    Title contains Helsinki city bikes

Contains navbar
    Navbar exists

Contains search form
    Get Element  form
    Get Element  form input
    Get Element  form button

Search contains placeholder text
    Get Attribute  form input  placeholder  ==  Search term

Searching adds query parameter search to url
    Type Text  form input  hello
    Click  form button
    Get URL  *=  search=hello

Navigating to next page updates page url
    Click  id=next-page
    Get URL  *=  page=2

Navigating to previous page updates page url
    Click  id=next-page
    Click  id=previous-page
    Get URL  *=  page=1
#+end_src

**** station.robot

These test the =/stations/<id>= path.

#+header: :tangle hcb-frontend/tests/station.robot
#+begin_src robot
,*** Settings ***
Documentation  Tests for the app's station page
Suite Setup     New Page  ${STATION_URL}
Resource       resource.robot

,*** Variables ***
${STATION_URL}  ${SERVER}/stations/1

,*** Test Cases ***
Title contains Helsinki city bikes
    Title contains Helsinki city bikes

Page contains station name
    Get Element  id=station-name

Page contains station address
    Get Element  id=station-address

Page contains details
    Get Element  text=Details for

Page contains journeys started here
    Get Element  text=Journeys started

Page contains journeys ended here
    Get Element  text=Journeys ended

Page contains average journey distance from here
    Get Element  text=Average journey from here

Page contains average journey distance to here
    Get Element  text=Average journey to here

Page contains top destinations
    Get Element  text=Top destinations

Page contains top origins
    Get Element  text=Top origins
#+end_src

*** requirements.txt

#+header: :tangle hcb-frontend/requirements.txt
#+begin_src python
Flask
psycopg2-binary
requests
#+end_src

*** The application entrypoint (main.py)

#+header: :tangle hcb-frontend/main.py
#+begin_src python
from flask import Flask, render_template, request, redirect, make_response, url_for, Response
from dataclasses import dataclass
import requests
import os
import ast
import functools
app = Flask(__name__)

backend_url = os.environ['HCBF_BACKEND_URL']
set_http_cache_headers = ast.literal_eval(os.environ['HCBF_SET_HTTP_CACHE_HEADERS'])
cache_max_age = int(os.environ['HCBF_CACHE_MAX_AGE'])

def maybe_set_cache_headers(response_creator):
    """Maybe add cache headers to a flask Response.

    Whether the headers are set depends on the value of
    set_http_cache_headers.

    """
    @functools.wraps(response_creator)
    def wrapper(*args, **kwargs):
        response = response_creator(*args, **kwargs)
        if not isinstance(response, Response):
            # wrap a template in a response object
            response = make_response(response)

        if set_http_cache_headers:
            # deprecated, does app engine still use it?
            # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Pragma
            # https://groups.google.com/g/google-appengine/c/6xAV2Q5x8AU/m/QI26C0ofvhwJ
            response.headers['Pragma'] = 'Public'
            response.headers['Cache-Control'] = f'public, max-age={cache_max_age}'
        return response
    return wrapper

@dataclass
class Journey:
    departure_station_id: int
    departure_station_name: str
    return_station_id: int
    return_station_name: str
    distance: float
    duration: int

@app.route('/journeys')
@maybe_set_cache_headers
def journeys():
    page = int(request.args.get('page', '1'))
    search_term = request.args.get('search', '')
    order_by = request.args.get('order_by')
    direction = request.args.get('direction')

    url = f'{backend_url}/journeys?page={page}'

    if search_term:
        url = f'{url}&search={search_term}'
    if order_by:
        url = f'{url}&order_by={order_by}'
    if direction == 'ascending':
        url = f'{url}&direction=asc'
    elif direction == 'descending':
        url = f'{url}&direction=desc'

    resp = requests.get(url)
    resp.raise_for_status()

    journeys = [Journey(**journey) for journey in resp.json()]

    return render_template(
        'journeys.html.j2',
        journeys=journeys,
        previous_page=max(page - 1, 1),
        next_page=page + 1,
        page=page,
        search_term=search_term,
        order_by=order_by,
        direction=direction
    )

@dataclass
class Station:
    id: int
    name: str
    address: str

@app.route('/stations')
@maybe_set_cache_headers
def stations():
    page = max(1, int(request.args.get('page', '1')))
    search_term = request.args.get('search', '')

    url = f'{backend_url}/stations?page={page}'

    if search_term:
        url = f'{url}&search={search_term}'
    resp = requests.get(url)
    resp.raise_for_status()
    stations = [Station(**station) for station in resp.json()]

    previous_page = None if page == 1 else page - 1
    next_page = page + 1
    return render_template(
        'stations.html.j2',
        stations=stations,
        previous_page=previous_page,
        page=page,
        next_page=next_page,
        search_term=search_term
    )


@dataclass
class StationRelationInfo:
    id: int
    name: str
    journeys: int

@dataclass
class StationInfo:
    name: str
    address: str
    x: float
    y: float
    journeys_started_here: int
    journeys_ended_here: int
    average_distance_started_here: int
    average_distance_ended_here: int
    top_destinations: list[StationRelationInfo]
    top_origins: list[StationRelationInfo]


@app.route('/stations/<int:station_id>')
@maybe_set_cache_headers
def station(station_id):
    months = request.args.getlist('month')
    if months == []:
        months = ('5', '6', '7')

    months = tuple(map(int, months))
    url = f'{backend_url}/stations/{station_id}?'

    for month in months:
        url = f'{url}month={month}&'

    response = requests.get(url)
    response.raise_for_status()
    data = response.json()
    station_info = StationInfo(
        name=data['name'],
        address=data['address'],
        x=data['x'],
        y=data['y'],
        journeys_started_here=data['journeys_started_here'],
        journeys_ended_here=data['journeys_ended_here'],
        average_distance_started_here=\
        data['average_distance_started_here'],
        average_distance_ended_here=\
        data['average_distance_ended_here'],
        top_destinations=[StationRelationInfo(**value) for value in data['top_destinations']],
        top_origins=[StationRelationInfo(**value) for value in data['top_origins']]
    )

    response = make_response(
        render_template(
            'station.html.j2',
            station=station_info,
            months=months
    ))

    return response

@app.route('/random-station')
def random_station():
    url = f'{backend_url}/stations/random'
    resp = requests.get(url)
    resp.raise_for_status()
    station_id = resp.json()
    return redirect(
        url_for('station', station_id=station_id)
    )

@app.route('/')
@maybe_set_cache_headers
def home():
    return render_template('home.html.j2')

if __name__ == "__main__":
    host = os.environ['HCBF_HOST']
    port = os.environ['HCBF_PORT']
    app.run(host=host, port=port, debug=True)
#+end_src

*** HTML templates

**** base.html.j2

This template is not rendered directly, instead other templates inherit and implement its blocks as needed.

#+header: :tangle hcb-frontend/templates/base.html.j2
#+begin_src jinja2
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link type="text/css" rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    {% block head_plus %}
    {% endblock head_plus %}
    <title>
      {% block title %}block title{% endblock title %} -- Helsinki city bikes
    </title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
  </head>
  <body>
    {% block navbar %}
      <nav class="navbar navbar-expand-lg bg-light">
        <div class="container-fluid">
          <a class="navbar-brand" href="{{ url_for('home') }}">Helsinki City Bikes</a>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
          </button>
          <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
              <li class="nav-item">
                <a class="nav-link" id="navbar-journeys-link" href="{{ url_for('journeys') }}">Journeys</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" id="navbar-stations-link" href="{{ url_for('stations') }}">Stations</a>
              </li>
            </ul>
          </div>
        </div>
      </nav>
    {% endblock navbar %}
    {% block content %}
      <p>Implement the content block</p>
    {% endblock content %}
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4" crossorigin="anonymous"></script>

    {% block body_plus %}
    {% endblock body_plus %}
  </body>
</html>
#+end_src

**** home.html.j2

Served when visiting =/=.

#+header: :tangle hcb-frontend/templates/home.html.j2
#+begin_src jinja2
{% extends "base.html.j2" %}

{% block title %}
  Home
{% endblock %}

{% block content %}
  <div class="container">
    <div class="row align-items-center">
      <div class="col d-flex justify-content-center">
        <p class="lead mt-5">
          Pick a table category from the top nav bar, or...
        </p>
      </div>
    </div>
    <div class="row align-items-center">
      <div class="col d-flex justify-content-center">
        <a id="random-station-button" class="btn btn-primary" href="{{ url_for('random_station') }}" role="button">Pick a random station</a>
      </div>
    </div>
  </div>
{% endblock %}
#+end_src

**** journeys.html.j2

Served when visiting =/journeys=.

#+header: :tangle hcb-frontend/templates/journeys.html.j2
#+begin_src jinja2
{% extends "base.html.j2" %}

{% block head_plus %}
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.4/font/bootstrap-icons.css">
{% endblock %}

{% block title %}
  Journeys
{% endblock %}

{% macro _header_link(column_name, column_id, column_readable_name, direction, sort_icon, search_term) %}
  <a id="{{ column_id }}" href="{{ url_for('journeys', page=1, search=search_term, order_by=column_name, direction=direction) }}">{{ column_readable_name }}</a>
  <i class="{{ sort_icon }}"></i>
{% endmacro %}

{% macro _table_header_element(column_name, column_id, column_readable_name, order_by, data_type, direction, search_term) %}
  {% if data_type == 'numeric' %}
    {% if direction == 'ascending' %}
      {% set icon = 'bi-sort-numeric-down' %}
    {% else %}
      {% set icon = 'bi-sort-numeric-up' %}
    {% endif %}
  {% elif data_type == 'alpha' %}
    {% if direction == 'ascending' %}
      {% set icon = 'bi-sort-alpha-down' %}
    {% else %}
      {% set icon = 'bi-sort-alpha-up' %}
    {% endif %}
  {% endif %}
  {% if column_name != order_by %}
    {% set icon = None %}
  {% endif %}

  <th>
    {% if order_by == column_name and direction == 'ascending' %}
      {{ _header_link(column_name, column_id, column_readable_name, 'descending', icon, search_term) }}
    {% else %}
      {{ _header_link(column_name, column_id, column_readable_name, 'ascending', icon, search_term) }}
    {% endif %}
  </th>
{% endmacro %}

{% block content %}
  <div class="container">
    <div class="row">
      <div class="col d-flex justify-content-center">
        <h1>Journeys</h1>
      </div>
    </div>
    <div class="row">
      <div class="col">
        <form>
          <div class="input-group" id="form">
            <input type="" class="form-control" placeholder="Search term" name="search" value="{{ search_term }}">
            <button type="submit" class="btn btn-primary">Search</button>
          </div>
        </form>
      </div>
    </div>
    <div class="row">
      <div class="col">
        <div class="table-responsive">
          <table class="table table-striped table-hover">
            <thead>
             <tr>
               {{ _table_header_element('departure_station', 'departure-station', 'Departure Station', order_by, 'alpha', direction, search_term) }}
               {{ _table_header_element('return_station', 'return-station', 'Return Station', order_by, 'alpha', direction, search_term) }}
               {{ _table_header_element('distance', 'distance', 'Covered distance (km)', order_by, 'numeric', direction, search_term) }}
               {{ _table_header_element('duration', 'duration', 'Duration (m)', order_by, 'numeric', direction, search_term) }}
              </tr>
            </thead>
            <tbody>
              {% for journey in journeys %}
                <tr>
                  <td>
                    <a href="{{ url_for('station', station_id=journey.departure_station_id) }}">
                      {{ journey.departure_station_name }}
                    </a>
                  </td>
                  <td>
                    <a href="{{ url_for('station', station_id=journey.return_station_id) }}">
                      {{ journey.return_station_name }}
                    </a>
                  </td>
                  <td>{{ journey.distance | round(1) }}</td>
                  <td>{{ journey.duration  }}</td>
                </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col d-flex justify-content-center">
        <ul class="pagination">
          <li class="page-item">
            <a
              class="page-link" id="previous-page"
              href="{{ url_for('journeys', page=previous_page, search=search_term, order_by=order_by, direction=direction) }}">
              Previous
            </a>
          </li>
          <li class="page-item">
            <a
              class="page-link"
              href="#">
              {{ page }}
            </a>
          </li>
          <li class="page-item">
            <a class="page-link" id="next-page"
               href="{{ url_for('journeys', page=next_page, search=search_term, order_by=order_by, direction=direction) }}">
               Next
            </a>
          </li>
        </ul>
      </div>
    </div>
  </div>
{% endblock content %}
#+end_src

**** stations.html.j2

Served when visiting =/stations=.

#+header: :tangle hcb-frontend/templates/stations.html.j2
#+begin_src jinja2
{% extends "base.html.j2" %}

{% block title %}
  Stations
{% endblock %}

{% block content %}
  <div class="container">
    <div class="row">
      <div class="col d-flex justify-content-center">
        <h1>Stations</h1>
      </div>
    </div>
    <div class="row">
      <div class="col">
        <form>
          <div class="input-group">
            <input type="" class="form-control" placeholder="Search term" name="search" value="{{ search_term }}">
            <button type="submit" class="btn btn-primary">Search</button>
          </div>
        </form>
      </div>
    </div>
    <div class="row">
      <div class="col">
        <div class="table-responsive">
          <table class="table table-striped table-hover">
            <thead>
              <tr>
                <th>Name</th>
                <th>Address</th>
              </tr>
            </thead>
            <tbody>
              {% for station in stations %}
                <tr>
                  <td>
                    <a href="{{ url_for('station', station_id=station.id) }}">
                      {{ station.name }}
                    </a>
                  </td>
                  <td>{{ station.address }}</td>
                </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col d-flex justify-content-center">
        <ul class="pagination">
          <li class="page-item">
            <a
              class="page-link" id="previous-page"
              href="{{ url_for('stations', page=previous_page, search=search_term) }}">
              Previous
            </a>
          </li>
          <li class="page-item">
            <a
              class="page-link"
              href="#">
              {{ page }}
            </a>
          </li>
          <li class="page-item">
            <a class="page-link" id="next-page"
               href="{{ url_for('stations', page=next_page, search=search_term) }}">
               Next
            </a>
          </li>
        </ul>
      </div>
    </div>
  </div>
{% endblock content %}
#+end_src

Served when visiting =station/<id>=.

#+header: :tangle hcb-frontend/templates/station.html.j2
#+begin_src jinja2
{% extends "base.html.j2" %}

{% block title %}
  {{ station.name }}
{% endblock %}

{% block content %}
  <div class="container">
    <div class="row">
      <div class="col-12 col-md-6">
        <div class="row py-3">
          <div class="col">
            <h1 id="station-name">{{ station.name }}</h1>
            <h2 id="station-address">{{ station.address }}</h2>
          </div>
        </div>
        <div class="row">
        </div>
        <div class="row">
          <div class="col">
            <div class="row py-1">
              <div class="col">
                <h3>Details for</h3>
                </div>
              <div class="col">
                <form>
              <input type="checkbox" class="btn-check" id="may" autocomplete="off" name="month" value="5"
                     {% if 5 in months %}
                       checked
                     {% endif %}>
              <label class="btn btn-outline-primary" for="may">May</label>

              <input type="checkbox" class="btn-check" id="june" autocomplete="off" name="month" value="6"
                     {% if 6 in months %}
                       checked
                     {% endif %}>
              <label class="btn btn-outline-primary" for="june">June</label>

              <input type="checkbox" class="btn-check" id="july" autocomplete="off" name="month" value="7"
                     {% if 7 in months %}
                       checked
                     {% endif %}>
              <label class="btn btn-outline-primary" for="july">July</label>

              <button type="submit" class="btn btn-primary">Recompute</button>
            </form>
              </div>
            </div>

            <table class="table">
              <thead>
                <tr>
                  <th>Journeys started here</th>
                  <th>Journeys ended here</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>{{ station.journeys_started_here }}</td>
                  <td>{{ station.journeys_ended_here }}</td>
                </tr>
              </tbody>
              <thead>
                <tr>
                  <th>Average journey from here (m)</th>
                  <th>Average journey to here (m)</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>{{ station.average_distance_started_here | int }}</td>
                  <td>{{ station.average_distance_ended_here | int }}</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <div class="row">
          <div class="col">
            <h3>Top destinations</h3>
            <table class="table">
              <thead>
                <tr>
                  <th>Station</th>
                  <th>Journeys</th>
                </tr>
              </thead>
              <tbody>
                {% for journey in station.top_destinations %}
                  <tr>
                    <td><a href="{{ url_for('station', station_id=journey.id) }}">{{ journey.name }}</a></td>
                    <td>{{ journey.journeys }}</td>
                  </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>
        <div class="row">
          <div class="col">
            <h3>Top origins</h3>
            <table class="table">
              <thead>
                <tr>
                  <th>Station</th>
                  <th>Journeys</th>
                </tr>
              </thead>
              <tbody>
                {% for journey in station.top_origins %}
                  <tr>
                    <td><a href="{{ url_for('station', station_id=journey.id) }}">{{ journey.name }}</a></td>
                    <td>{{ journey.journeys }}</td>
                  </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>
      </div>
      <div class="col-12 col-md-6">
        <div id="osm-map"></div>
      </div>
    </div>
  </div>
{% endblock content %}

{% block body_plus %}
  <script>
    x = {{ station.x }}
    y = {{ station.y }}
  </script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
  <script src="{{ url_for('static', filename="osm.js") }}"></script>
{% endblock body_plus %}
#+end_src

*** osm.js

A small bit of Javascript to draw the little marker on the openstreetmap map.

#+header: :tangle hcb-frontend/static/osm.js
#+begin_src js
var element = document.getElementById('osm-map');

element.style = 'height:600px;'

var map = L.map(element);

L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
}).addTo(map);

var target = L.latLng(y, x);

map.setView(target, 13);

L.marker(target)
  .addTo(map);
#+end_src

*** style.css

Custom css, which there obviously is not a lot of.

#+header: :tangle hcb-frontend/static/style.css
#+begin_src css

#+end_src

* Google Cloud

The following configuration sets up the frontend and backend as services in [[https://cloud.google.com/appengine][App Engine]], and also creates a =default= service.

The app is accessible at [[https://helsinki-city-bikes-383419.lm.r.appspot.com]] and at [[https://hcb.rkll.net]].

** dispatch.yaml

#+header: :tangle dispatch.yaml
#+begin_src yaml
dispatch:
  - url: 'helsinki-city-bikes-383419.lm.r.appspot.com/*'
    service: hcb-frontend

  - url: 'hcb.rkll.net/*'
    service: hcb-frontend
#+end_src

** Services

*** default

**** requirements.txt

#+header: :tangle default-service/requirements.txt
#+begin_src text
Flask
#+end_src

**** .gcloudignore

I use a directory named =env= as a python virtual environment

#+header: :tangle default-service/.gcloudignore
#+begin_src text
env
#+end_src

**** app.yaml

#+header: :tangle default-service/app.yaml
#+begin_src yaml
runtime: python311
service: default
#+end_src

**** main.py

#+header: :tangle default-service/main.py
#+begin_src python
from flask import Flask
import os

app = Flask(__name__)

if __name__ == "__main__":
    import os

    host = os.environ['HCBF_HOST']
    port = os.environ['HCBF_PORT']
    app.run(host=host, port=port, debug=True)
#+end_src

*** Frontend configuration

**** .gcloudignore

#+header: :tangle hcb-frontend/.gcloudignore
#+begin_src text
env
tests
#+end_src

**** app.yaml

#+header: :tangle hcb-frontend/app.yaml
#+begin_src yaml
runtime: python311
service: hcb-frontend
env_variables:
  HCBF_BACKEND_URL: https://hcb-backend-dot-helsinki-city-bikes-383419.lm.r.appspot.com
  HCBF_SET_HTTP_CACHE_HEADERS: True
  HCBF_CACHE_MAX_AGE: 3600
#+end_src

*** Backend configuration

**** .gcloudignore

#+header: :tangle hcb-backend/.gcloudignore
#+begin_src text
env
tests
#+end_src

**** app.yaml

#+header: :tangle hcb-backend/app.yaml
#+begin_src yaml
runtime: python311

service: hcb-backend

env_variables:
  PSQL_DB: hcb
  PSQL_USER: postgres
  PSQL_PASS: jafpiB-jukhe4-qutsox
  PSQL_HOST: /cloudsql/helsinki-city-bikes-383419:europe-central2:helsinki-city-bikes
  PSQL_PORT: 5432
  HCBB_SET_HTTP_CACHE_HEADERS: True
  HCBB_CACHE_MAX_AGE: 3600
#+end_src

*** Database export

Here we =pg_dump= a locally created database to disk, so that we can import it into [[https://cloud.google.com/sql][Cloud SQL]].  Upload the dump to [[https://cloud.google.com/storage][Cloud Storage]], and import it in [[https://cloud.google.com/sql][Cloud SQL]].

#+begin_src sh
docker run --rm -it --network=hcb -ePGPASSWORD=postgres postgres pg_dump -U postgres -h hcb-postgres -d hcb | gzip > pg.dmp.gz
#+end_src
